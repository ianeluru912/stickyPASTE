#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('robot.py', b'from controller import Robot as WebotsRobot # type: ignore\r\nfrom map import Map, Tile, TileType\r\nfrom image import ImageProcessor\r\nfrom point import Point\r\nfrom piso import Piso\r\nfrom lidar import Lidar\r\nfrom rectangle import Rectangle\r\nfrom navigator import Navigator\r\nfrom comm import Comm\r\nimport math\r\nimport utils\r\nimport struct\r\nimport numpy as np\r\nimport random\r\nfrom visualization import MapVisualizer\r\nimport persona\r\n\r\nTIME_STEP = 16\r\nMAX_VEL = 6.28\r\n\r\nclass Robot:\r\n    def __init__(self):\r\n        self.yo=persona.YO\r\n        self.otro=persona.OTRO\r\n        self.violetasDelOtro=[]\r\n        self.misVioletas=[]\r\n        self.hiceMiLaburo=False\r\n        self.zonaTerminada=False\r\n        \r\n        self.robot = WebotsRobot()\r\n        receiver = self.robot.getDevice("receiver")\r\n        receiver.enable(TIME_STEP)\r\n        self.comm=Comm(self.robot.getDevice("emitter"), receiver,self)\r\n        self.wheelL = self.robot.getDevice("wheel1 motor")\r\n        self.wheelL.setPosition(float("inf"))\r\n\r\n        self.wheelR = self.robot.getDevice("wheel2 motor")\r\n        self.wheelR.setPosition(float("inf"))\r\n\r\n        self.lidar = Lidar(self.robot.getDevice("lidar"), TIME_STEP)\r\n\r\n        self.inertialUnit = self.robot.getDevice("inertial_unit")\r\n        self.inertialUnit.enable(TIME_STEP)\r\n\r\n        self.gps = self.robot.getDevice("gps")\r\n        self.gps.enable(TIME_STEP)\r\n\r\n        self.colorSensor = self.robot.getDevice("colour_sensor")\r\n        self.colorSensor.enable(TIME_STEP)\r\n\r\n        self.camI = self.robot.getDevice("camaraIzquierda")\r\n        self.camI.enable(TIME_STEP)\r\n\r\n        self.camD = self.robot.getDevice("camaraDerecha")\r\n        self.camD.enable(TIME_STEP)\r\n\r\n        self.imageProcessor = ImageProcessor()\r\n    \r\n        self.position = None\r\n        self.lastPosition=None\r\n        self.rotation = 0\r\n        self.posicion_inicial = None\r\n        self.targetPoint = None\r\n\r\n        self.step_counter = 0\r\n\r\n        self.navigator = Navigator(self)\r\n        self.lastZ = None\r\n        # self.holeIZ = self.imageProcessor.see_hole()\r\n        # self.holeDER = self.imageProcessor.see_hole()\r\n        self.wheelL.setVelocity(0)\r\n        self.wheelR.setVelocity(0)\r\n        self.map = None\r\n        self.stepInit()\r\n        self.posicion_inicial = self.position\r\n        self.map = Map(self.posicion_inicial)\r\n        self.current_area = 1\r\n        inicio=self.map.getTileAtPosition(self.posicion_inicial)\r\n        inicio.set_area(self.current_area)\r\n        inicio.type = TileType.STARTING\r\n        self.doingLOP = False\r\n\r\n        self.mapvis = MapVisualizer()\r\n        self.lastRequestTime = 0\r\n\r\n        self.gameScore=0\r\n        self.timeRemaining=10000\r\n        self.realTimeRemaining=10000\r\n\r\n    def getNavigator(self):\r\n        return self.navigator\r\n\r\n    def getTime(self):\r\n        return self.robot.getTime()\r\n    \r\n    def stepInit(self): # este step lo hace una vez al comienzo de todo\r\n        result = self.robot.step(TIME_STEP)\r\n        self.step_counter += 1\r\n        self.updatePosition()\r\n        self.updateRotation()\r\n        self.updateLidar()\r\n        self.updateCamerasDetection()\r\n        return result\r\n\r\n\r\n    def step(self):\r\n        result = self.robot.step(TIME_STEP)\r\n        self.step_counter += 1\r\n        self.updateVars()\r\n        self.mapvis.send_robot(self)\r\n        return result\r\n\r\n    def delay(self, ms):\r\n        initTime = self.robot.getTime()\r\n        while self.robot.step(TIME_STEP) != -1:\r\n            if (self.robot.getTime() - initTime) * 1000.0 >= ms:\r\n                break\r\n\r\n    def updateVioleta(self):\r\n        self.comm.recibirMensajes()\r\n            \r\n            \r\n    def updateVars(self):\r\n        self.updatePosition()\r\n        self.updateRotation()\r\n        self.updateLidar()\r\n        self.updateCamerasDetection()\r\n        self.updateTiles()\r\n        self.updateVioleta()\r\n        # self.updateGameScoreAndTimes()\r\n        \r\n        if self.map != None:\r\n            x = self.position.x - self.posicion_inicial.x\r\n            y = self.position.y - self.posicion_inicial.y\r\n            x_valid = utils.near_multiple(x, base=0.06, tolerance=0.0025)\r\n            y_valid = utils.near_multiple(y, base=0.06, tolerance=0.0025)\r\n            if x_valid and y_valid:\r\n                self.updateMap()\r\n\r\n    def updateGameScoreAndTimes(self):\r\n\r\n        if self.robot.getTime() - self.lastRequestTime > 1: #Defino ac\xc3\xa1 cada cu\xc3\xa1nto quiero que me actualice los datos\r\n            auxGameScore, auxTimeRemaining, auxRealTimeRemaining = self.comm.getGameScoreAndtimeRemaining()\r\n            if auxGameScore is not None:\r\n                self.gameScore = auxGameScore\r\n                self.timeRemaining = auxTimeRemaining\r\n                self.realTimeRemaining = auxRealTimeRemaining\r\n            self.lastRequestTime = self.robot.getTime()\r\n\r\n    def updateTiles(self):\r\n        tile=self.getTilePointedByColorSensor()\r\n        \r\n        if not(tile is None) and tile.type is None:\r\n            self.classifyTile(tile)\r\n            \r\n    def updateCamerasDetection(self):\r\n        return self.enviar_mensaje_imgs()\r\n\r\n    def enviarMensajeVoC(self, entrada):\r\n        # print("Enviando mensaje VoC")\r\n        if self.yo==0 and entrada==\'S\':\r\n            return\r\n        if self.yo==1 and entrada==\'H\':\r\n            return\r\n        \r\n        self.parar()\r\n        self.delay(1500)\r\n        self.comm.sendToken(int(self.position.x * 100), int(self.position.y * 100), entrada, self.yo)\r\n        self.delay(100)\r\n        if entrada=="S" and self.yo==1:\r\n            print(f"Yo {self.yo} apagu\xc3\xa9 el fuego")\r\n            self.hiceMiLaburo=True\r\n        if entrada=="H" and self.yo==0: \r\n            print(f"Yo {self.yo} saqu\xc3\xa9 el agua")\r\n            self.hiceMiLaburo=True\r\n\r\n\r\n    def convertir_camara(self, img, alto, ancho):  \r\n            img_a_convertir = np.array(np.frombuffer(img, np.uint8).reshape((alto, ancho, 4)))\r\n            return img_a_convertir\r\n    \r\n    def mappingVictim2(self, side, token): # side = "L" o "R" token = cartelito o v\xc3\xadctima\r\n        # obtener la distancia del rayito 128 si es la L o 384 si es la R. Para calcular targetPoint, si es L, la rotaci\xc3\xb3n del \r\n        # robot + pi/2, si es R, la rotaci\xc3\xb3n del robot - pi/2\r\n        if side == "L":\r\n            dist = self.lidar.rangeImage[128]\r\n            rot=self.rotation+math.pi/2\r\n        else:\r\n            dist = self.lidar.rangeImage[384]\r\n            rot=self.rotation-math.pi/2\r\n        # usando targetPoint, obtener el punto de la pared donde estar\xc3\xada el cartel.\r\n        targetPoint=utils.targetPoint(self.position, rot, dist)\r\n        # pedirle a map que me de el tile en esa posici\xc3\xb3n\r\n        tileToTag=self.map.getTileAtPosition(targetPoint)\r\n        # print(tileToTag.col, tileToTag.row, token) # ES correcto el tile que calcul\xc3\xb3 donde est\xc3\xa1 la v\xc3\xadctima????\r\n        # agregar en tile un m\xc3\xa9todo que dado un punto, me diga qu\xc3\xa9 pared es (NL, NC, NR, SL, SC, SR, EU, EC, ED, WU, WC, WD, IN, IS, IE, IW)\r\n        tileToTag.setTokenOnAWall(targetPoint, token)\r\n    \r\n    def mappingVictim(self, side, token): # side = "L" o "R" token = cartelito o v\xc3\xadctima\r\n        #TODO: falla en el mapeo cuando detecta una v\xc3\xadctima estando en diagonal\r\n        # self.mappingVictim2(side, token)\r\n        umbralPared=0.01\r\n        umbralRotation=math.pi/10\r\n        if not utils.near_multiple(self.rotation, math.pi/2, umbralRotation):\r\n            return\r\n\r\n        orientation=self.obtener_orientacion(self.rotation)\r\n        \r\n        xRobot = self.position.x\r\n        yRobot = self.position.y\r\n        xRobotRel = abs(xRobot - self.posicion_inicial.x)\r\n        yRobotRel = abs(yRobot - self.posicion_inicial.y)\r\n        if orientation == "N" or orientation == "S":\r\n            # si mi posici\xc3\xb3n en x est\xc3\xa1 en el borde entre baldosas, yo estoy viendo la v\xc3\xadctima en una pared interna\r\n            # si no, lo estoy viendo en una pared externda\r\n            #if xRobotRel is near a multiple of 0.12\r\n            if not(utils.near_multiple(xRobotRel, 0.12, 0.03)):\r\n                # print("NS Estoy en el borde entre dos baldosas", xRobotRel, yRobotRel)\r\n                # Estoy caminando entre dos baldosas, es decir, estoy viendo algo en una pared interna vertical\r\n                if side == "L":\r\n                    if orientation == "N":\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x-0.02, self.position.y))\r\n                    else: # estoy yendo para el sur\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x+0.02, self.position.y))\r\n                else: # estoy viendo con la c\xc3\xa1mara derecha\r\n                    if orientation == "N":\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x+0.02, self.position.y))   \r\n                    else: # estoy yendo para el sur\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x-0.02, self.position.y))\r\n\r\n                # para saber si es la pared interna vertical de arriba o de abajo, voy a fijarme si estoy m\xc3\xa1s arriba o m\xc3\xa1s\r\n                # abajo de la mitad de la baldosa\r\n                yTtoTag=self.map.gridToPosition(tileToTag.col, tileToTag.row).y\r\n                if yRobot<yTtoTag:\r\n                    tileToTag.tokensVerticalInternalWall[0]=token\r\n                else:\r\n                    tileToTag.tokensVerticalInternalWall[1]=token\r\n            else:\r\n                # Estoy caminando en el medio de una baldosa\r\n                # print("NS Estoy en el medio de una baldosa", xRobotRel, yRobotRel)\r\n                tileToTag=self.map.getTileAtPosition(self.position)\r\n                if side == "L": # es la c\xc3\xa1mara izquierda\r\n                    if orientation == "N":                    \r\n                        wall=tileToTag.tokensWest\r\n                    else: # estoy yendo para el sur\r\n                        wall=tileToTag.tokensEast\r\n                else:\r\n                    if orientation == "N":\r\n                        wall=tileToTag.tokensEast\r\n                    else: # estoy yendo para el sur\r\n                        wall=tileToTag.tokensWest\r\n                yTtoTag=tileToTagPosition=self.map.gridToPosition(tileToTag.col, tileToTag.row).y \r\n                if yRobot< yTtoTag-umbralPared: #Considero que estoy en la parte superior de la baldosa\r\n                    wall[0]=token\r\n                elif yRobot> yTtoTag+umbralPared: # PArte inferior\r\n                    wall[2]=token\r\n                else: # En el medio de la pared\r\n                    wall[1]=token \r\n        else: # orientaci\xc3\xb3n de E a W\r\n            # si mi posici\xc3\xb3n en y est\xc3\xa1 en el borde entre baldosas, yo estoy viendo la v\xc3\xadctima en una pared interna\r\n            # si no, lo estoy viendo en una pared externa\r\n            if not(utils.near_multiple(yRobotRel, 0.12, 0.03)): \r\n                # print("EO Estoy en el borde entre dos baldosas", yRobotRel, yRobot)\r\n                # Estoy caminando entre dos baldosas, es decir, estoy viendo algo en una pared interna horizontal\r\n                if side == "L":\r\n                    if orientation == "E":\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x, self.position.y-0.02))\r\n                    else: # estoy yendo para el oeste\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x, self.position.y+0.02))\r\n                else: # estoy viendo con la c\xc3\xa1mara derecha\r\n                    if orientation == "E":\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x, self.position.y+0.02))   \r\n                    else: # estoy yendo para el sur\r\n                        tileToTag=self.map.getTileAtPosition(Point(self.position.x, self.position.y-0.02))\r\n\r\n                # para saber si es la pared interna horizontal de izq o derecha, voy a fijarme si estoy m\xc3\xa1s izq\r\n                # o derecha de la mitad de la baldosa\r\n                xTtoTag=self.map.gridToPosition(tileToTag.col, tileToTag.row).x\r\n                if xRobot<xTtoTag:\r\n                    tileToTag.tokensHorizontalInternalWall[0]=token\r\n                else:\r\n                    tileToTag.tokensHorizontalInternalWall[1]=token\r\n            else:\r\n                # Estoy caminando en el medio de una baldosa\r\n                # print("EO Estoy en el medio de una baldosa", xRobotRel, yRobotRel)\r\n                tileToTag=self.map.getTileAtPosition(self.position)\r\n                if side == "L": # es la c\xc3\xa1mara izquierda\r\n                    if orientation == "E":                    \r\n                        wall=tileToTag.tokensNorth\r\n                    else: # estoy yendo para el oeste\r\n                        wall=tileToTag.tokensSouth\r\n                else:\r\n                    if orientation == "E":\r\n                        wall=tileToTag.tokensSouth\r\n                    else: # estoy yendo para el oeste\r\n                        wall=tileToTag.tokensNorth\r\n                xTtoTag=tileToTagPosition=self.map.gridToPosition(tileToTag.col, tileToTag.row).x \r\n                if xRobot< xTtoTag-umbralPared: #Considero que estoy en la parte inferior de la baldosa\r\n                    wall[0]=token\r\n                elif xRobot> xTtoTag+umbralPared: # PArte superior\r\n                    wall[2]=token\r\n                else: # En el medio de la pared\r\n                    wall[1]=token \r\n\r\n    def enviar_mensaje_imgs(self):\r\n        if self.lidar.hayAlgoIzquierda():\r\n            entrada_I = self.imageProcessor.procesar(self.convertir_camara(self.camI.getImage(), 64, 64))\r\n            if entrada_I is not None:\r\n                self.mappingVictim2("L", entrada_I)\r\n                self.enviarMensajeVoC(entrada_I)\r\n        \r\n        if self.lidar.hayAlgoDerecha():\r\n            entrada_D = self.imageProcessor.procesar(self.convertir_camara(self.camD.getImage(), 64, 64))\r\n            if entrada_D is not None:\r\n                self.mappingVictim2("R", entrada_D)\r\n                self.enviarMensajeVoC(entrada_D)\r\n    \r\n    def updatePosition(self):\r\n        x, _, y = self.gps.getValues()\r\n        _, z, _ = self.gps.getValues()\r\n        self.position = Point(x, y)\r\n  \r\n        if self.lastZ is None:\r\n            self.lastZ = z\r\n        else:\r\n            # if self.lastZ-z>0.002: # se fue a un z m\xc3\xa1s bajo, se cay\xc3\xb3...\r\n            if z<-0.015:\r\n                #print("Me ca\xc3\xad")\r\n                self.position = Point(x, y)\r\n                tile=self.map.getTileAtPosition(self.position)\r\n                # print(f"Me ca\xc3\xad en el tile ({tile.col}, {tile.row})")\r\n                tile.type=TileType.BLACK_HOLE\r\n            self.lastZ = z\r\n\r\n            \r\n        if self.lastPosition is None:\r\n            self.lastPosition = self.position\r\n        else:\r\n            previousTile = self.map.getTileAtPosition(self.lastPosition)\r\n            currentTile = self.map.getTileAtPosition(self.position)\r\n            if currentTile != previousTile: # Entramos a una nueva baldosa\r\n                previousTile.visits += 1\r\n\r\n                if not self.doingLOP:\r\n                    if currentTile.get_area() is None:\r\n                        if not currentTile.isColorPassage():\r\n                            currentTile.set_area(self.current_area)\r\n                        # print(f"Tile en ({tile.col}, {tile.row}) marcada en area {tile.area}")\r\n                    else:\r\n                        self.current_area = currentTile.get_area()\r\n                        # print(f"Robot ahora en area {self.current_area} en el tile ({currentTile.col}, {currentTile.row})")\r\n                    \r\n                    color = currentTile.type\r\n                    if color:\r\n                        self.update_area_by_color(color)\r\n                        currentTile.set_area(self.current_area)\r\n\r\n            if self.lastPosition.distance_to(self.position) > 0.02:\r\n                # print("LOP")\r\n                # generate a random number betweeen -pi and pi\r\n                angle = random.uniform(-math.pi, math.pi)\r\n                # rotate the robot by that angle\r\n                # self.girar(angle)\r\n                self.doingLOP = True\r\n                self.current_area = currentTile.get_area()\r\n                tileDangerous=self.map.getTileAtPosition(self.lastPosition)\r\n                tileDangerous.dangerous=True\r\n                self.lastPosition = self.position\r\n            else:\r\n                self.lastPosition = self.position\r\n                self.doingLOP = False\r\n\r\n    def updateRotation(self):\r\n        _, _, yaw = self.inertialUnit.getRollPitchYaw()\r\n        self.rotation = self.normalizar_radianes(yaw % math.tau)\r\n\r\n    def updateLidar(self):\r\n        self.lidar.update()\r\n\r\n    def girar(self, rad):\r\n        lastRot = self.rotation\r\n        deltaRot = 0\r\n\r\n        while self.step() != -1:\r\n            if self.doingLOP:\r\n                self.wheelL.setVelocity(0)\r\n                self.wheelR.setVelocity(0)\r\n                break\r\n            deltaRot += utils.angle_diff(self.rotation, lastRot)\r\n            lastRot = self.rotation\r\n\r\n            diff = utils.angle_diff(deltaRot, abs(rad))\r\n\r\n            mul = (5/math.pi) * diff\r\n            mul = min(max(mul, 0.05), 1)\r\n\r\n            if rad > 0:\r\n                self.wheelL.setVelocity(mul*(MAX_VEL/3))\r\n                self.wheelR.setVelocity(-mul*(MAX_VEL/3))\r\n            else:\r\n                self.wheelL.setVelocity(-mul*(MAX_VEL/3))\r\n                self.wheelR.setVelocity(mul*(MAX_VEL/3))\r\n\r\n            if diff <= 0.005:\r\n                break\r\n\r\n        self.wheelL.setVelocity(0)\r\n        self.wheelR.setVelocity(0)\r\n\r\n    def avanzar(self, distance, shouldBrake):\r\n        initPos = self.position\r\n        goBack = False\r\n\r\n        while self.step() != -1:\r\n            if self.doingLOP:\r\n                self.wheelL.setVelocity(0)\r\n                self.wheelR.setVelocity(0)\r\n                break\r\n\r\n            diff = abs(distance) - initPos.distance_to(self.position)\r\n\r\n            vel = 1\r\n            if shouldBrake:\r\n                vel = min(max(diff/0.01, 0.1), 1)\r\n                \r\n            if distance < 0: vel *= -1\r\n\r\n            self.wheelL.setVelocity(vel*MAX_VEL)\r\n            self.wheelR.setVelocity(vel*MAX_VEL)\r\n\r\n            if distance > 0:\r\n                ray_idx, dist = self.lidar.getNearestObstacle()\r\n                if ray_idx is not None:\r\n                    ray_offset = 256 - ray_idx\r\n                    delta_angle = ray_offset * (2*math.pi/512)\r\n                    angle = self.normalizar_radianes(self.rotation + delta_angle)\r\n                    target_point = utils.targetPoint(self.position, angle, dist)\r\n                    # print(f"position: {self.position}, rotation: {self.rotation}")\r\n                    # print(f"ray_idx: {ray_idx}, dist: {dist}")\r\n                    # print(f"ray_offset: {ray_offset}, delta_angle: {delta_angle}")\r\n                    # print(f"angle: {angle}")\r\n                    # print(f"target_point: {target_point}")\r\n                    self.map.addObstacle(target_point)\r\n                    self.addBlockedPath(initPos, self.targetPoint)\r\n                    goBack = True\r\n                    break\r\n            \r\n                if self.targetPoint != None:\r\n                    top = self.targetPoint.y - 0.02\r\n                    left = self.targetPoint.x - 0.02\r\n                    bottom = self.targetPoint.y + 0.02\r\n                    right = self.targetPoint.x + 0.02\r\n                    tiles = self.map.getTilesIntersecting(Rectangle(top, left, bottom, right))\r\n                    count = 0\r\n                    for tile in tiles:\r\n                        if tile.type == TileType.BLACK_HOLE:\r\n                            count += 1\r\n                    if count >= len(tiles) / 2:\r\n                        goBack = True\r\n                        break\r\n\r\n            if diff < 0.001:\r\n                break\r\n\r\n        if shouldBrake or goBack:\r\n            self.wheelL.setVelocity(0)\r\n            self.wheelR.setVelocity(0)\r\n\r\n        if goBack:\r\n            dist = initPos.distance_to(self.position)\r\n            self.avanzar(-dist, True)\r\n\r\n    def addBlockedPath(self, start, dest):\r\n        navigator = self.getNavigator()\r\n        navigator.addBlockedPath(start, dest)\r\n    \r\n    def bh_izq(self):\r\n        # TODO(Richo): Este c\xc3\xb3digo asume navegaci\xc3\xb3n de centro de baldosa a centro de baldosa\r\n        orientation = self.obtener_orientacion(self.rotation)\r\n        if orientation == \'N\':\r\n            if self.isOpenWest():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camI.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'E\':\r\n            if self.isOpenNorth():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camI.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'S\':\r\n            if self.isOpenEast():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camI.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'W\':\r\n            if self.isOpenSouth():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camI.getImage(), 64, 64))\r\n            return False   \r\n\r\n    def bh_der(self):\r\n        # TODO(Richo): Este c\xc3\xb3digo asume navegaci\xc3\xb3n de centro de baldosa a centro de baldosa\r\n        orientation = self.obtener_orientacion(self.rotation)\r\n        if orientation == \'N\':\r\n            if self.isOpenEast():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camD.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'E\':\r\n            if self.isOpenSouth():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camD.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'S\':\r\n            if self.isOpenWest():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camD.getImage(), 64, 64))\r\n            return False\r\n        elif orientation == \'W\':\r\n            if self.isOpenNorth():\r\n                return self.imageProcessor.see_hole(self.convertir_camara(self.camD.getImage(), 64, 64))\r\n            return False\r\n\r\n    def parar(self):\r\n        self.wheelL.setVelocity(0)\r\n        self.wheelR.setVelocity(0)\r\n\r\n    def normalizar_radianes(self, radianes): # radianes seria la rotacion actual del robot\r\n        if radianes > math.pi:\r\n            radianes -= math.pi*2\r\n            return radianes\r\n        elif radianes < -math.pi:\r\n            radianes += math.pi*2\r\n            return radianes\r\n        return radianes\r\n    \r\n    def obtener_orientacion(self, radianes):\r\n        # TODO(Richo): Este c\xc3\xb3digo asume que no nos movemos en diagonal\r\n        angulo = self.normalizar_radianes(radianes)\r\n        if angulo >= 0.785 and angulo <= 2.355:\r\n            return \'W\'\r\n        elif angulo >= -2.355 and angulo <= -0.785:\r\n            return \'E\'\r\n        elif angulo >= -0.785 and angulo <= 0.785:\r\n            return \'N\'\r\n        else:\r\n            return \'S\'\r\n        \r\n    def isOpenNorth(self):\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        return self.lidar.isOpenNorth(orient)        \r\n\r\n    def isOpenSouth(self):\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        return self.lidar.isOpenSouth(orient)\r\n        \r\n    def isOpenWest(self):\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        return self.lidar.isOpenWest(orient)\r\n        \r\n    def isOpenEast(self):\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        return self.lidar.isOpenEast(orient)\r\n    \r\n    def get_tile_ahead(self):\r\n        col, row = self.map.positionToGrid(self.position)\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        if orient == "N":\r\n            return self.map.getTileAt(col, row - 1)\r\n        elif orient == "S":\r\n            return self.map.getTileAt(col, row + 1)\r\n        elif orient == "E":            \r\n            return self.map.getTileAt(col + 1, row)\r\n        elif orient == "W":            \r\n            return self.map.getTileAt(col - 1, row)\r\n        \r\n    def get_tile_izq(self):\r\n        col, row = self.map.positionToGrid(self.position)\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        if orient == "N":\r\n            return self.map.getTileAt(col - 1, row)\r\n        elif orient == "S":\r\n            return self.map.getTileAt(col + 1, row)\r\n        elif orient == "E":            \r\n            return self.map.getTileAt(col, row - 1)\r\n        elif orient == "W":\r\n            return self.map.getTileAt(col, row + 1)\r\n        \r\n    def get_tile_der(self):\r\n        col, row = self.map.positionToGrid(self.position)\r\n        orient = self.obtener_orientacion(self.rotation)\r\n        if orient == "N":\r\n            return self.map.getTileAt(col + 1, row)\r\n        elif orient == "S":\r\n            return self.map.getTileAt(col - 1, row)\r\n        elif orient == "E":\r\n            return self.map.getTileAt(col, row + 1)\r\n        elif orient == "W":\r\n            return self.map.getTileAt(col, row - 1)\r\n\r\n    def updateMap(self):\r\n        rect = self.getRectangle()\r\n        tiles_intersecting = self.map.getTilesIntersecting(rect)\r\n        if len(tiles_intersecting) == 1:\r\n            # print(f"{self.step_counter} -> CASO 1")\r\n            self.updateMap1(tiles_intersecting[0])\r\n        elif len(tiles_intersecting) == 2:\r\n            direction = tiles_intersecting[0].getDirectionTo(tiles_intersecting[1])\r\n            if direction == "S" or direction == "N":\r\n                # Caso 2\r\n                # print(f"{self.step_counter} -> CASO 2")\r\n                self.lidar.updateWalls2(self.rotation, self.map, tiles_intersecting)\r\n            else:\r\n                # Caso 3\r\n                # print(f"{self.step_counter} -> CASO 3")\r\n                self.lidar.updateWalls3(self.rotation, self.map, tiles_intersecting)\r\n        elif len(tiles_intersecting) >= 3:\r\n            # print(f"{self.step_counter} -> CASO 4")\r\n            # print(\'valores rayitos:\', self.lidar.ver_walls(self.rotation))\r\n            # print(\'---\')\r\n            # print(\'valores paredes:\', self.lidar.get_walls_4(self.rotation))\r\n            self.lidar.updateWalls4(self.rotation, self.map, tiles_intersecting)\r\n\r\n        self.mapvis.send_map(self.map)\r\n\r\n    def updateMap1(self, tile):\r\n        self.lidar.updateWalls1(self.rotation, self.map, tile)\r\n\r\n    def classifyTile(self, tile):\r\n        # print(tile.type)\r\n        b, g, r, _ = self.colorSensor.getImage()\r\n        m = Piso(r, g, b)\r\n        # if tile.col==8 and tile.row==2:\r\n        #     print(f"Tile en ({tile.col}, {tile.row})")\r\n        #     print(f"Color: {r}, {g}, {b}")\r\n        #     print(utils.targetPoint(self.position, self.rotation, 0.084))\r\n\r\n        \r\n        if tile.type is None:\r\n            if m.blackHole():\r\n                tile.type = TileType.BLACK_HOLE\r\n                tile.set_area(self.current_area)      \r\n            elif m.pantano():\r\n                tile.type = TileType.SWAMP\r\n                tile.set_area(self.current_area)\r\n            elif m.blue():\r\n                tile.type = TileType.BLUE\r\n                if (self.yo==1):\r\n                    tile.dangerous=True   \r\n            elif m.green():\r\n                tile.type = TileType.GREEN\r\n            elif m.purple():\r\n                tile.type = TileType.PURPLE\r\n\r\n            elif m.red():\r\n                tile.type = TileType.RED\r\n                if (self.yo==0):\r\n                    tile.dangerous=True\r\n            elif m.orange():\r\n                tile.type = TileType.ORANGE\r\n            elif m.yellow():\r\n                tile.type = TileType.YELLOW\r\n            elif m.checkpoint():\r\n                tile.type = TileType.CHECKPOINT\r\n                tile.set_area(self.current_area)\r\n            elif m.estandar():\r\n                tile.type = TileType.STANDARD\r\n                tile.set_area(self.current_area)\r\n                if (tile.dangerous):\r\n                    tile.dangerous=False\r\n\r\n            # if tile.type is not None:\r\n            #     print(f"Acabo de clasificar el tile ({tile.col}, {tile.row}) como {tile.type}")    \r\n\r\n            self.mapvis.send_map(self.map)\r\n          \r\n    def update_area_by_color(self, color):\r\n        possibleAreas = {\r\n            (1, TileType.BLUE): 2, #area 1, azul? area 2\r\n            (1, TileType.YELLOW): 3,\r\n            (1, TileType.GREEN): 4,\r\n            (2, TileType.BLUE): 1, #area 2, azul? area 1\r\n            (2, TileType.PURPLE): 3, #""\r\n            (2, TileType.ORANGE): 4,\r\n            (3, TileType.YELLOW): 1,\r\n            (3, TileType.PURPLE): 2,\r\n            (3, TileType.RED): 4,\r\n            (4, TileType.GREEN): 1,\r\n            (4, TileType.ORANGE): 2,\r\n            (4, TileType.RED): 3\r\n        }\r\n\r\n        changeOfArea = (self.current_area, color)\r\n        if changeOfArea in possibleAreas:\r\n            self.current_area = possibleAreas[changeOfArea]\r\n            # print(f"Area actualizada a {self.current_area} por color {color}")\r\n\r\n    def getTilePointedByColorSensor(self):\r\n    \r\n        if(self.lidar.rangeImage[256]>0.084):\r\n            pointCS=utils.targetPoint(self.position, self.rotation, 0.084)\r\n            enBordeEnX=utils.puntoEnBordeX(self.posicion_inicial, pointCS)\r\n            enBordeEnY=utils.puntoEnBordeY(self.posicion_inicial, pointCS)\r\n\r\n            if enBordeEnX or enBordeEnY:\r\n                # print("No te clasifico, tile")\r\n                return None\r\n\r\n            return self.map.getTileAtPosition(pointCS)\r\n        else:\r\n            # Tengo algo delante que no me deja ver el tile\r\n            return None\r\n\r\n    def moveToPoint(self, target_pos, shouldBrake):\r\n        self.targetPoint = target_pos\r\n        target_vector = Point(target_pos.x - self.position.x, target_pos.y - self.position.y)\r\n        target_ang = target_vector.angle()\r\n        delta_ang = self.normalizar_radianes(target_ang - self.rotation)\r\n        self.girar(delta_ang)\r\n        self.avanzar(target_vector.length(), shouldBrake)\r\n        tile=self.map.getTileAtPosition(self.position)\r\n        if tile.type==TileType.PURPLE:\r\n            if (tile.col, tile.row) not in self.misVioletas:\r\n                self.misVioletas.append((tile.col, tile.row))\r\n                print(f"Yo soy {self.yo} Mis violetas Tienen esto:", self.misVioletas)\r\n                self.comm.llegueAVioleta(tile.col, tile.row)\r\n            # # si el otro ya hab\xc3\xada llegado a violeta, y tiene uno distinto al m\xc3\xado,\\\r\n            # # me quedo parado y le doy la orden de que vaya a ese\r\n            # posiblesDelOtro=self.violetasDelOtro.copy()\r\n            # if (tile.col, tile.row) in posiblesDelOtro:\r\n            #     posiblesDelOtro.remove((tile.col, tile.row))\r\n\r\n            # if len(posiblesDelOtro)>0:\r\n            #     self.comm.llegueAVioleta(tile.col, tile.row)\r\n            #     self.comm.andaPalla(posiblesDelOtro[0][0], posiblesDelOtro[0][1])\r\n            #     self.parar()\r\n            #     while(self.step()!=-1):\r\n            #         # Esperar que el otro me mande mensaje de que lleg\xc3\xb3 a violeta\r\n            #         if self.zonaTerminada:\r\n            #             self.zonaTerminada=False\r\n            #             self.misVioletas=[]\r\n            #             self.violetasDelOtro=[]\r\n            #             break\r\n            # else:\r\n            # # si no, le mando el mensaje del violeta adonde llegu\xc3\xa9 y sigo navegando\r\n            #     if (tile.col, tile.row) not in self.misVioletas:\r\n            #         self.misVioletas.append((tile.col, tile.row))\r\n            #         self.comm.llegueAVioleta(tile.col, tile.row)\r\n            \r\n                \r\n\r\n    def getRectangle(self):\r\n        diameter = 0.07\r\n        left = self.position.x - diameter/2\r\n        right = self.position.x + diameter/2\r\n        top = self.position.y - diameter/2\r\n        bottom = self.position.y + diameter/2\r\n        return Rectangle(top, left, bottom, right)\r\n    \r\n    def exit(self, rep):\r\n       \r\n        self.comm.sendMap(rep)\r\n        self.comm.sendExit()')
    __stickytape_write_module('map.py', b'from point import Point\r\nfrom rectangle import Rectangle\r\nfrom enum import Enum\r\nimport numpy as np\r\n\r\nclass TileType(Enum):\r\n    BLACK_HOLE = \'2\'\r\n    SWAMP = \'3\'\r\n    CHECKPOINT = \'4\'\r\n    STARTING = \'5\'\r\n    BLUE = \'b\'\r\n    YELLOW = \'y\'\r\n    GREEN = \'g\'\r\n    PURPLE = \'p\'\r\n    ORANGE = \'o\'\r\n    RED = \'r\'\r\n    STANDARD = \'s\'\r\n\r\nclass Map:\r\n    def __init__(self, origin) -> None:\r\n        self.origin = origin\r\n        self.tiles = {}\r\n        self.obstacles = []\r\n\r\n    def addObstacle(self, point):\r\n        self.obstacles.append(point)\r\n\r\n    def getObstacleRectangle(self, obstacle):\r\n        top = obstacle.y - 0.02\r\n        left = obstacle.x - 0.02\r\n        bottom = obstacle.y + 0.02\r\n        right = obstacle.x + 0.02\r\n        return Rectangle(top, left, bottom, right)\r\n\r\n    def gridToPosition(self, col, row):\r\n        x = self.origin.x + col * Tile.WIDTH\r\n        y = self.origin.y + row * Tile.HEIGHT\r\n        return Point(x, y)\r\n\r\n    def positionToGrid(self, pos):\r\n        columna = round((pos.x - self.origin.x) / Tile.WIDTH)\r\n        fila = round((pos.y - self.origin.y) / Tile.HEIGHT)\r\n        return (columna, fila)\r\n\r\n    def getTileAt(self, col, row):\r\n        tile = self.tiles.get((col, row))\r\n        if tile == None:\r\n            tile = Tile(col, row, self)\r\n            self.tiles[(col, row)] = tile\r\n        return tile\r\n    \r\n    def getTileAtPosition(self, point):\r\n        col, row = self.positionToGrid(point)\r\n        return self.getTileAt(col, row)\r\n    \r\n    def getTileRectangle(self, col, row):\r\n        position = self.gridToPosition(col, row)\r\n        left = position.x - Tile.WIDTH/2\r\n        right = position.x + Tile.WIDTH/2\r\n        top = position.y - Tile.HEIGHT/2\r\n        bottom = position.y + Tile.HEIGHT/2\r\n        return Rectangle(top, left, bottom, right)\r\n    \r\n    def getTilesIntersecting(self, rectangle):\r\n        result = []\r\n        for tile in self.tiles.values():\r\n            tile_rect = self.getTileRectangle(tile.col, tile.row)\r\n            if tile_rect.intersects(rectangle):\r\n                result.append(tile)\r\n        return result\r\n            \r\n    def writeMap(self, file_path, robot):\r\n        col, row = self.positionToGrid(robot.position)\r\n        orientation = robot.obtener_orientacion(robot.rotation)\r\n        # Primero buscamos los extremos del mapa, que nos servira para iterar\r\n        # en la grilla en el orden correcto.\r\n        min_col, min_row, max_col, max_row = 0, 0, 0, 0\r\n        for c, r in self.tiles:\r\n            t = self.tiles.get((c, r))\r\n            if t == None or not t.isConnected(): continue # Ignoramos baldosas aisladas\r\n            if c < min_col: min_col = c\r\n            if r < min_row: min_row = r\r\n            if c > max_col: max_col = c\r\n            if r > max_row: max_row = r\r\n        # Luego revisamos una por una cada baldosa y calculamos los caracteres\r\n        # a imprimir de acuerdo a sus caracteristicas (si es la baldosa de\r\n        # inicio, si tiene vecinos cuales, si fue visitada, etc.)\r\n        char_groups = []\r\n        for r in range(min_row, max_row + 1):\r\n            char_group = []\r\n            for c in range(min_col, max_col + 1):\r\n                t = self.tiles.get((c, r))\r\n                chars = [["+", "-", "+"],\r\n                        ["|", "X", "|"],\r\n                        ["+", "-", "+"]]\r\n                if t != None:\r\n                    if c == col and r == row:\r\n                        chars[1][1] = orientation\r\n                    elif c == 0 and r == 0:\r\n                        chars[1][1] = "@"\r\n                    elif not t.isConnected():\r\n                        chars[1][1] = "X"\r\n                    elif t.type==TileType.BLACK_HOLE:\r\n                        chars[1][1] = "B"\r\n                    elif t.type==TileType.BLUE:\r\n                        chars[1][1] = "A"\r\n                    elif t.visits == 0:\r\n                        chars[1][1] = "?"\r\n                    else:\r\n                        chars[1][1] = " "\r\n                    \r\n                    if t.north != None: chars[0][1] = " "\r\n                    if t.east != None: chars[1][2] = " "\r\n                    if t.south != None: chars[2][1] = " "\r\n                    if t.west != None: chars[1][0] = " "\r\n                char_group.append(chars)\r\n            char_groups.append(char_group)\r\n        # Finalmente, abrimos el archivo y escribimos los caracteres que\r\n        # representan a cada baldosa\r\n        with open(file_path, "w") as f:\r\n            for char_group in char_groups:\r\n                for i in range(0, 3):\r\n                    for chars in char_group:\r\n                        f.write("".join(chars[i]))\r\n                    f.write("\\n")\r\n    \r\n    def getValidTiles(self):\r\n        salida=[tile for tile in self.tiles.values() if tile.isValid()]\r\n        return salida\r\n    \r\n    def combineTilesReg(self, tileMapa, tileAUbicar):\r\n        # en cada casilla del mapa que recibe tengo 1, 0, una letra o un *\r\n        # None<*<0,1<letra\r\n        for i in range(5):\r\n            for j in range(5):\r\n                # print(i,j)\r\n                # Si lo que viene es un None, no lo pongo.\r\n                if tileAUbicar[i, j] == None:\r\n                    # print("Caso 1")\r\n                    # No hace nada\r\n                    continue\r\n\r\n                # Sino, si lo que recibe es un None, pongo lo que venga\r\n                elif tileMapa[i, j] == None:\r\n                    # print("Caso 2")\r\n                    tileMapa[i, j] = tileAUbicar[i, j]\r\n \r\n                # Sino, si lo que ten\xc3\xada es un * pongo lo que venga (porque s\xc3\xa9 que no es un None)\r\n                elif tileMapa[i, j] == "*":\r\n                    # print("Caso 3")\r\n                    tileMapa[i, j] = tileAUbicar[i, j]\r\n                \r\n                # Sino, si lo que ten\xc3\xada es un 0 o un 1, y lo que viene es una letra, pongo la letra\r\n                elif (tileMapa[i, j] == "0" or tileMapa[i, j] == "1") and (tileAUbicar[i, j] != "0" and \\\r\n                    tileAUbicar[i, j] != "1" and tileAUbicar[i, j] != "*"):\r\n                    # print("Caso 4")\r\n                    tileMapa[i, j] = tileAUbicar[i, j]\r\n\r\n                \r\n\r\n    def combineTilesReal(self, tileMapa, tileAUbicar):\r\n        # en cada casilla del mapa que recibe tengo 1, 0, una letra o un *\r\n        # None<*<0,1<letra\r\n        for i in range(5):\r\n            for j in range(5):\r\n                # print(i,j)\r\n                # Si lo que viene es un None O LO QUE TENGO ES UN ASTERISCO, no lo pongo.\r\n                if tileAUbicar[i, j] == None or tileMapa[i, j] == "*":\r\n                    # print("Caso 1")\r\n                    # No hace nada\r\n                    continue\r\n\r\n                # Sino, si lo que recibe es un None, pongo lo que venga\r\n                elif tileMapa[i, j] == None or tileAUbicar[i, j] == "*":\r\n                    # print("Caso 2")\r\n                    tileMapa[i, j] = tileAUbicar[i, j]\r\n \r\n                # Sino, si lo que ten\xc3\xada es un 0 o un 1, y lo que viene es una letra, pongo la letra\r\n                elif (tileMapa[i, j] == "0" or tileMapa[i, j] == "1") and (tileAUbicar[i, j] != "0" and \\\r\n                    tileAUbicar[i, j] != "1"):\r\n                    # print("Caso 4")\r\n                    tileMapa[i, j] = tileAUbicar[i, j]\r\n                \r\n                elif tileMapa[i, j] != "1" and tileMapa[i, j] != "0" and tileAUbicar[i, j] != "1" and tileAUbicar[i, j] != "1":\r\n                    old = tileMapa[i, j]\r\n                    new = tileAUbicar[i, j]\r\n                    if new in "HSU" and not (old in "HSU"):\r\n                        tileMapa[i, j] = new + old\r\n                    else:\r\n                        tileMapa[i, j] = old + new\r\n\r\n                # Si ten\xc3\xadamos un 0 o un 1, y viene un 0 o un 1, deber\xc3\xada ser coherente. No hacemos nada\r\n    \r\n    def getRepresentation(self):\r\n        # obtener tiles validos\r\n        valid_tiles = self.getValidTiles()\r\n        #TODO: En los tiles de \xc3\xa1rea 4, poner asteriscos (ver d\xc3\xb3nde)\r\n        # detectar la columnna m\xc3\xadnima y m\xc3\xa1xima de los tiles v\xc3\xa1lidos\r\n        colmin = min([tile.col for tile in valid_tiles])\r\n        colmax = max([tile.col for tile in valid_tiles])\r\n        rowmin = min([tile.row for tile in valid_tiles])\r\n        rowmax = max([tile.row for tile in valid_tiles])\r\n\r\n        totCol=(colmax-colmin+1)*4+1\r\n        totRow=(rowmax-rowmin+1)*4+1\r\n        repre=np.full((totRow, totCol), None)\r\n\r\n        valid_tiles.sort(key=lambda t: t.col)\r\n        valid_tiles.sort(key=lambda t: t.row)\r\n\r\n        for tile in valid_tiles:\r\n\r\n            # Calcula la columna donde tiene que poner el tile dentro de la representaci\xc3\xb3n\r\n            col=(tile.col-colmin)*4\r\n            # Calcula la fila donde tiene que poner el tile dentro de la representaci\xc3\xb3n\r\n            row=(tile.row-rowmin)*4\r\n            # Obtiene la representaci\xc3\xb3n del tile\r\n            rep=tile.getRepresentation()\r\n            # Combinar lo que ya hab\xc3\xada en la representaci\xc3\xb3n con lo que acabo de obtener.\r\n            # if tile.col==1 and tile.row==1:\r\n            #     print(f"Col: {tile.col}, Row: {tile.row}")\r\n            #     print("Tile")\r\n            #     print(rep)\r\n            #     print("El que recibe el tile")\r\n            #     print(repre[row:row+5, col:col+5])\r\n            #     print("====")\r\n\r\n            # ACAACA CAMBIAR POR COMBINETILESREG SI EL ASTERISCO ES LO QUE MENOS PESA (COMO MUESTRA EL EJEMPLO DEL REGLAMENTO)\r\n            self.combineTilesReal(repre[row:row+5, col:col+5], rep)\r\n            # if tile.col==1 and tile.row==1:\r\n            #     print("Como qued\xc3\xb3 despu\xc3\xa9s de la combineta")\r\n            #     print(repre[row:row+5, col:col+5])\r\n        \r\n        for i in range(totRow):\r\n            for j in range(totCol):\r\n                if repre[i, j] == None:\r\n                    repre[i, j] = \'0\' #ACAACA Conviene poner 0 o *?????\r\n        return repre\r\n\r\n    def existTileAt(self, col, row):\r\n        return (col, row) in self.tiles      \r\n\r\n  \r\nclass Tile:\r\n    WIDTH = 0.12  \r\n    HEIGHT = 0.12\r\n\r\n    def __init__(self, col, row, map) -> None:\r\n        self.__map = map\r\n        self.col = col\r\n        self.row = row\r\n        self.visits = 0\r\n        \r\n        self.north = [-1, -1, -1]\r\n        self.west = [-1, -1, -1]\r\n        self.east = [-1, -1, -1]\r\n        self.south = [-1, -1, -1]\r\n\r\n        self.tokensNorth = [0,0,0]\r\n        self.tokensWest = [0,0,0]\r\n        self.tokensEast = [0,0,0]\r\n        self.tokensSouth = [0,0,0]\r\n\r\n        self.tokensVerticalInternalWall=[0,0]\r\n        self.tokensHorizontalInternalWall=[0,0]\r\n\r\n        self.type=None\r\n        self.area = None\r\n        self.dangerous=False\r\n    \r\n    def __str__(self) -> str:\r\n        return f"Tile ({self.col}, {self.row}) {self.getRepresentation()}"\r\n        \r\n    def getRectangle(self):\r\n        return self.__map.getTileRectangle(self.col, self.row)\r\n\r\n    def getNorthTile(self):\r\n        return self.__map.getTileAt(self.col, self.row - 1)\r\n    \r\n    def getEastTile(self):\r\n        return self.__map.getTileAt(self.col + 1, self.row)\r\n\r\n    def getSouthTile(self):\r\n        return self.__map.getTileAt(self.col, self.row + 1)\r\n\r\n    def getWestTile(self):\r\n        return self.__map.getTileAt(self.col - 1, self.row)\r\n    \r\n    def isNVOrA4OrAN(self):\r\n        return not(self.isValid()) or self.area==4 or self.area==None\r\n    \r\n    def oneOrMoreNeighborsAreArea4(self):\r\n        return self.getNorthTile().area==4 or self.getEastTile().area==4 or self.getSouthTile().area==4 or self.getWestTile().area==4\r\n\r\n    def getRepresentation(self):\r\n        # create a numpy array 5x5\r\n        # Agregar en la tile las v\xc3\xadctimas y carteles \r\n        # Agregar paredes internas\r\n  \r\n        # si es area 4, hacer todos * y retornarlo\r\n        if self.area == 4:\r\n            return np.full((5,5), "*")\r\n        \r\n        if self.area == None and self.oneOrMoreNeighborsAreArea4() and self.getNorthTile().isNVOrA4OrAN() and self.getEastTile().isNVOrA4OrAN() and self.getSouthTile().isNVOrA4OrAN() and self.getWestTile().isNVOrA4OrAN():\r\n            return np.full((5,5), "*")\r\n        \r\n\r\n        rep=np.full((5,5), None)\r\n        # Agregar las paredes externas\r\n        # Dado que la representaci\xc3\xb3n de la pared sur y la oeste est\xc3\xa1n invertidas, nos creamos una versi\xc3\xb3n dada vuelta para generar\r\n        # la representaci\xc3\xb3n de la pared sur y la oeste\r\n        # create a copy of the south and west walls reversed\r\n        south_reversed = self.south.copy()\r\n        south_reversed.reverse()\r\n        west_reversed = self.west.copy()\r\n        west_reversed.reverse()\r\n\r\n        # if self.col==0 and self.row==-1:\r\n        #     print("Estoy analizando la baldosa 0,-1")\r\n        #     print(self.__map.existTileAt(self.col-1, self.row))\r\n        #     tile=self.__map.getTileAt(self.col-1, self.row)\r\n        #     print(tile.isValid())\r\n\r\n        if self.__map.getTileAt(self.col, self.row-1).isValid():\r\n            northWall=self.getWallRepresentation(self.north)\r\n        else:\r\n            northWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n\r\n        if self.__map.getTileAt(self.col+1, self.row).isValid():\r\n            eastWall=self.getWallRepresentation(self.east)\r\n        else:\r\n            eastWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n\r\n        if self.__map.getTileAt(self.col, self.row+1).isValid():\r\n            southWall=self.getWallRepresentation(south_reversed)\r\n        else:\r\n            southWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n\r\n        if self.__map.getTileAt(self.col-1, self.row).isValid():\r\n            westWall=self.getWallRepresentation(west_reversed)\r\n        else:\r\n            westWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n\r\n\r\n        # if not(self.__map.existTileAt(self.col, self.row+1)):\r\n        #     southWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n        # else:\r\n        #     southWall=self.getWallRepresentation(south_reversed)\r\n\r\n        # if not(self.__map.existTileAt(self.col-1, self.row)):\r\n        #     westWall=[\'1\',\'1\',\'1\',\'1\',\'1\']\r\n        # else:\r\n        #     westWall=self.getWallRepresentation(west_reversed)\r\n\r\n        rep[0,0:5]=self.combinesWall(rep[0,0:5], northWall)\r\n        rep[0:5,4]=self.combinesWall(rep[0:5,4], eastWall)\r\n        rep[4,0:5]=self.combinesWall(rep[4,0:5], southWall)\r\n        rep[0:5,0]=self.combinesWall(rep[0:5,0], westWall)\r\n\r\n\r\n        # TODO:Agregar las paredes internas\r\n        # Pared interna vertical superior, es el valor del medio de self.north\r\n        if self.north[1]==1:\r\n            rep[0:3,2]=self.combinesWall(rep[0:3,2], [\'1\', \'1\', \'1\'])\r\n        elif self.north[1]==0:\r\n            rep[0:3,2]=self.combinesWall(rep[0:3,2], [\'0\', \'0\', \'0\'])\r\n        # Pared interna vertical inferior, es el valor del medio de self.south\r\n        if self.south[1]==1:\r\n            rep[2:5,2]=self.combinesWall(rep[2:5,2], [\'1\', \'1\', \'1\'])\r\n        elif self.south[1]==0:\r\n            rep[2:5,2]=self.combinesWall(rep[2:5,2], [\'0\', \'0\', \'0\'])\r\n        # Pared interna horizontal izquierda, es el valor del medio de self.west\r\n        if self.west[1]==1:\r\n            rep[2,0:3]=self.combinesWall(rep[2,0:3], [\'1\', \'1\', \'1\'])\r\n        elif self.west[1]==0:\r\n            rep[2,0:3]=self.combinesWall(rep[2,0:3], [\'0\', \'0\', \'0\'])\r\n        # Pared interna horizontal derecha, es el valor del medio de self.east\r\n        if self.east[1]==1:\r\n            rep[2,2:5]=self.combinesWall(rep[2,2:5], [\'1\', \'1\', \'1\'])\r\n        elif self.east[1]==0:\r\n            rep[2,2:5]=self.combinesWall(rep[2,2:5], [\'0\', \'0\', \'0\'])\r\n\r\n\r\n        # Agregar el color de la baldosa\r\n        if not(self.type==TileType.STANDARD or self.type==None):\r\n            rep[1, 1]=rep[1, 3]=rep[3, 1]=rep[3, 3]=self.type.value\r\n\r\n        # DONE: Agregar las v\xc3\xadctimas y carteles\r\n        if self.tokensNorth != [0, 0, 0]:\r\n            if self.tokensNorth[0] != 0:\r\n                rep[0, 1] = self.tokensNorth[0]\r\n            if self.tokensNorth[1] != 0:\r\n                rep[0, 2] = self.tokensNorth[1]\r\n            if self.tokensNorth[2] != 0:\r\n                rep[0, 3] = self.tokensNorth[2]\r\n\r\n        if self.tokensSouth != [0, 0, 0]:\r\n            if self.tokensSouth[0] != 0:\r\n                rep[4, 1] = self.tokensSouth[0]\r\n            if self.tokensSouth[1] != 0:\r\n                rep[4, 2] = self.tokensSouth[1]\r\n            if self.tokensSouth[2] != 0:\r\n                rep[4, 3] = self.tokensSouth[2]\r\n\r\n        if self.tokensWest != [0, 0, 0]:\r\n            if self.tokensWest[0] != 0:\r\n                rep[1, 0] = self.tokensWest[0]\r\n            if self.tokensWest[1] != 0:\r\n                rep[2, 0] = self.tokensWest[1]\r\n            if self.tokensWest[2] != 0:\r\n                rep[3, 0] = self.tokensWest[2]\r\n\r\n        if self.tokensEast != [0, 0, 0]:\r\n            if self.tokensEast[0] != 0:\r\n                rep[1, 4] = self.tokensEast[0]\r\n            if self.tokensEast[1] != 0:\r\n                rep[2, 4] = self.tokensEast[1]\r\n            if self.tokensEast[2] != 0:\r\n                rep[3, 4] = self.tokensEast[2]\r\n        \r\n        #TODO: Agregar v\xc3\xadcitmas y carteles internos\r\n        if not(self.tokensVerticalInternalWall[0]==0):\r\n            rep[1,2]=self.tokensVerticalInternalWall[0]\r\n        if not(self.tokensVerticalInternalWall[1]==0):\r\n            rep[3,2]=self.tokensVerticalInternalWall[1]\r\n        if not(self.tokensHorizontalInternalWall[0]==0):\r\n            rep[2,1]=self.tokensHorizontalInternalWall[0]\r\n        if not(self.tokensHorizontalInternalWall[1]==0):\r\n            rep[2,3]=self.tokensHorizontalInternalWall[1]\r\n        \r\n        #Si es un black hole no me importa si detect\xc3\xb3 paredes internas o lo que sea, el formato es siempre el mismo.\r\n        if self.type==TileType.BLACK_HOLE:\r\n            rep[1,1:4]=[\'2\',\'0\',\'2\']\r\n            rep[2,1:4]=[\'0\',\'0\',\'0\']\r\n            rep[3,1:4]=[\'2\',\'0\',\'2\']\t\r\n        \r\n        for fil in range(1,rep.shape[0]-1):\r\n                for colum in range(1,rep.shape[1]-1):\r\n                    if rep[fil, colum] is None:\r\n                        rep[fil, colum] = \'0\'\r\n        \r\n            \r\n        return rep\r\n\r\n    def maxWall(self, v1, v2):\r\n        if v1==\'1\' or v2==\'1\':\r\n            return \'1\'\r\n        if v1==\'0\' and v2==\'0\':\r\n            return \'0\'\r\n        return None\r\n\r\n    def combinesWall(self, w1, w2):\r\n        size=len(w1)\r\n        sol=np.full(size, None)\r\n        for i in range(size):\r\n            sol[i]=self.maxWall(w1[i],w2[i])\r\n        return sol\r\n\r\n    def getWallRepresentation(self, wall):\r\n        left=wall[0]\r\n        right=wall[2]\r\n        if left==-1 and right==-1:\r\n            return [None, None, None, None, None]\r\n        elif left==-1 and right==0:\r\n            return [None, None, \'0\', \'0\', \'0\']\r\n        elif left==-1 and right==1:\r\n            return [None, None, \'1\', \'1\', \'1\']\r\n        elif left==0 and right==-1:\r\n            return [\'0\', \'0\', \'0\', None, None]\r\n        elif left==0 and right==0:\r\n            return [\'0\', \'0\', \'0\', \'0\', \'0\']\r\n        elif left==0 and right==1:\r\n            return [\'0\', \'0\', \'1\', \'1\', \'1\']\r\n        elif left==1 and right==-1:\r\n            return [\'1\', \'1\', \'1\', None, None]\r\n        elif left==1 and right==0:\r\n            return [\'1\', \'1\', \'1\', \'0\', \'0\']\r\n        elif left==1 and right==1:\r\n            return [\'1\', \'1\', \'1\', \'1\', \'1\']\r\n\r\n\r\n    def getDirectionTo(self, tile):\r\n        sc = self.col\r\n        sr = self.row\r\n        dc = tile.col\r\n        dr = tile.row\r\n        if dc - sc == 0: # Misma columna\r\n            if dr - sr > 0: return "S"\r\n            if dr - sr < 0: return "N"\r\n        elif dr - sr == 0: # Misma fila\r\n            if dc - sc > 0: return "E"\r\n            if dc - sc < 0: return "W"\r\n        return None\r\n    \r\n    def isConnectedTo(self, tile):\r\n        direction = self.getDirectionTo(tile)\r\n        if direction == "N":\r\n            return self.north == [0, 0, 0]\r\n        elif direction == "S":\r\n            return self.south == [0, 0, 0]\r\n        elif direction == "E":\r\n            return self.east == [0, 0, 0]\r\n        elif direction == "W":\r\n            return self.west == [0, 0, 0]\r\n        return False\r\n    \r\n    def isConnected(self):\r\n        if self.north != None: \r\n            return True\r\n        elif self.west != None:\r\n            return True\r\n        elif self.east != None:\r\n            return True\r\n        elif self.south != None:\r\n            return True\r\n        return False\r\n    \r\n    def set_area(self, area):\r\n        if self.isColorPassage(): return\r\n        self.area = area\r\n\r\n    def get_area(self):\r\n        return self.area\r\n    \r\n    def isColorPassage(self):\r\n        colored_types = [TileType.BLUE, TileType.YELLOW, TileType.GREEN, \\\r\n                         TileType.PURPLE, TileType.ORANGE, TileType.RED]\r\n        return self.type in colored_types\r\n    \r\n    def isValid(self):\r\n        #join self.north,self.west,self.east,self.south\r\n        walls=self.north+self.west+self.east+self.south\r\n        # if there is a 0 in the walls, then it is a valid tile\r\n        return 0 in walls\r\n    \r\n    def isOpenAt(self, pos):\r\n        center = self.__map.gridToPosition(self.col, self.row)\r\n        thresh = 0.02\r\n        if pos.x < center.x - thresh:\r\n            if pos.y < center.y - thresh:\r\n                # NW\r\n                return self.north[0] <= 0 and self.west[2] <= 0\r\n            elif pos.y > center.y + thresh:\r\n                # SW\r\n                return self.south[2] <= 0 and self.west[0] <= 0\r\n            else:\r\n                # W\r\n                return self.west[0] <= 0 and self.west[1] <= 0 and self.west[2] <= 0\r\n        elif pos.x > center.x + thresh:\r\n            if pos.y < center.y - thresh:\r\n                # NE\r\n                return self.north[2] <= 0 and self.east[0] <= 0\r\n            elif pos.y > center.y + thresh:\r\n                # SE\r\n                return self.east[2] <= 0 and self.south[0] <= 0\r\n            else:\r\n                # E\r\n                return self.east[0] <= 0 and self.east[1] <= 0 and self.east[2] <= 0\r\n        else:\r\n            if pos.y < center.y - thresh:\r\n                # N\r\n                return self.north[0] <= 0 and self.north[1] <= 0 and self.north[2] <= 0\r\n            elif pos.y > center.y + thresh:\r\n                # S\r\n                return self.south[0] <= 0 and self.south[1] <= 0 and self.south[2] <= 0\r\n            else: \r\n                # CENTRO!\r\n                return self.north[1] <= 0 and self.east[1] <= 0 and self.south[1] <= 0 and self.west[1] <= 0\r\n\r\n    def setTokenOnAWall(self, point, token):\r\n        # print(token)\r\n        # print(self.col, self.row)\r\n        center = self.__map.gridToPosition(self.col, self.row)\r\n        umbralChico = 0.015 #0.02\r\n        umbralGrande = 0.05\r\n        difx=center.x-point.x\r\n        dify=center.y-point.y\r\n        if difx > umbralChico and difx<umbralGrande:\r\n            if dify> umbralGrande:\r\n                # print("Norte Izquierda")\r\n                self.tokensNorth[0]=token\r\n            elif dify<-umbralGrande:\r\n                # print("Sur Izquierda")\r\n                self.tokensSouth[0]=token\r\n            else:\r\n                # print("Interna izquierda")\r\n                self.tokensHorizontalInternalWall[0]=token\r\n\r\n        elif difx>umbralGrande:\r\n            if dify>umbralChico:\r\n                # print("Oeste Arriba")\r\n                self.tokensWest[0]=token\r\n            elif dify<-umbralChico:\r\n                # print("Oeste Abajo")\r\n                self.tokensWest[2]=token\r\n            else:\r\n                # print("Oeste Medio")\r\n                # ACAACA SI NO LO ARREGLAN, LO VAMOS A PONER ARRIBA\r\n                # self.tokensWest[1]=token # ACAACA ESTO ES LO CORRECTO!!!!!!!!\r\n                self.tokensWest[0]=token\r\n        elif difx<=umbralChico and difx>=-umbralChico:\r\n            if dify>umbralGrande:\r\n                # print("Norte Medio")\r\n                # ACAACA SI NO LO ARREGLAN, LO VAMOS A PONER A LA IZQUIERDA\r\n                # self.tokensNorth[1]=token # ACAACA ESTO ES LO CORRECTO!!!!!!!!\r\n                self.tokensNorth[0]=token\r\n            elif dify>=umbralChico and dify<=umbralGrande:\r\n                # print("Interna Arriba")\r\n                self.tokensVerticalInternalWall[0]=token\r\n            elif dify<=-umbralChico and dify>=-umbralGrande:\r\n                # print("Interna Abajo")\r\n                self.tokensVerticalInternalWall[1]=token\r\n            else:\r\n                # print("Sur Medio")\r\n                # ACAACA SI NO LO ARREGLAN, LO VAMOS A PONER A LA IZQUIERDA\r\n                # self.tokensSouth[1]=token # ACAACA ESTO ES LO CORRECTO!!!!!!!!\r\n                self.tokensSouth[0]=token\r\n        elif difx<-umbralChico and difx>-umbralGrande:\r\n            if dify>umbralGrande:\r\n                # print("Norte derecha")\r\n                self.tokensNorth[2]=token\r\n            elif dify<-umbralGrande:\r\n                # print("Sur Derecha")\r\n                self.tokensSouth[2]=token\r\n            else:\r\n                # print("Interna derecha")\r\n                self.tokensHorizontalInternalWall[1]=token\r\n        else:\r\n            if dify>umbralChico:\r\n                # print("Este Arriba")\r\n                self.tokensEast[0]=token\r\n            elif dify<-umbralChico:\r\n                # print("Este Abajo")\r\n                self.tokensEast[2]=token\r\n            else:\r\n                # print("Este Medio")\r\n                # ACAACA SI NO LO ARREGLAN, LO VAMOS A PONER ARRIBA\r\n                #self.tokensEast[1]=token # ACAACA ESTO ES LO CORRECTO!!!!!!!!\r\n                self.tokensEast[0]=token\r\n            ')
    __stickytape_write_module('point.py', b'import math\r\nclass Point:\r\n    \r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n        \r\n    def length(self):\r\n        return math.sqrt(self.x*self.x + self.y*self.y)\r\n    \r\n    def angle(self):\r\n        return math.atan2(-self.x, -self.y)\r\n    \r\n    def distance_to(self, point):\r\n        dx = self.x-point.x\r\n        dy = self.y-point.y\r\n        return math.sqrt(dx**2 + dy**2)\r\n    \r\n    def __str__(self) -> str:\r\n        return f"({self.x:.3f}, {self.y:.3f})"\r\n    \r\n    def subtract(self, point):\r\n        return Point(self.x - point.x, self.y - point.y)\r\n    ')
    __stickytape_write_module('rectangle.py', b'from point import Point\r\nimport math\r\n\r\nclass Rectangle:\r\n    def __init__(self, top, left, bottom, right):\r\n        self.top = top\r\n        self.bottom = bottom\r\n        self.left = left\r\n        self.right = right\r\n\r\n        self.topLeft = Point(self.left, self.top)\r\n        self.bottomRight = Point(self.right, self.bottom)\r\n\r\n    def intersects(self, rect):\r\n        a = self\r\n        b = rect\r\n        if b.left > a.right: return False\r\n        if b.top > a.bottom: return False\r\n        if b.right < a.left: return False\r\n        if b.bottom < a.top: return False\r\n        return True    \r\n    ')
    __stickytape_write_module('image.py', b'import cv2\r\nimport numpy as np\r\nfrom datetime import datetime\r\nimport utils\r\n\r\nclass ImageProcessor:\r\n    def __init__(self):\r\n        self.img = None\r\n        self.salida = None\r\n\r\n    def debugShow(self, image):\r\n        cv2.imshow("V", image)\r\n        cv2.waitKey(0)\r\n        cv2.destroyAllWindows()\r\n\r\n    def es_victima(self):\r\n        if self.img is None or self.img.size == 0:\r\n            return None\r\n        \r\n        gris = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)\r\n        _, thresh = cv2.threshold(gris, 100, 255, cv2.THRESH_BINARY)\r\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n\r\n        return contours if len(contours) == 1 and len(contours[0]) <= 10 else None\r\n    \r\n    def devolver_letra_victimas(self):\r\n        self.salida = None\r\n        recorte=0 # Este recorte lo vamos a utilizar cuando realizamos una transformaci\xc3\xb3n del cartel deformado\r\n        # para sacarle algunos bordes negritos que nos quedan\r\n\r\n        \r\n        gris = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)\r\n        _, thresh = cv2.threshold(gris, 160, 255, cv2.THRESH_BINARY)\r\n        paraMostrarDespues=thresh.copy()\r\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n        if len(contours) == 0:\r\n\r\n            return self.salida\r\n\r\n\r\n        if len(contours) == 1:\r\n            if len(contours[0]) > 10:\r\n                # print(len(contours), len(contours[0]))\r\n                # print("Encontr\xc3\xa9 un cartel que parece una letra pero tiene demasiados puntos su contorno")\r\n                # self.debugShow(thresh)\r\n                # \xc2\xbfTiene thresh una cantidad de pixeles blancos razonables?\r\n                # pixeles_blancos = np.count_nonzero(thresh == 255)\r\n                # tamanio = thresh.shape[0] * thresh.shape[1]\r\n                # porcentaje_blancos = pixeles_blancos / tamanio\r\n                # print("Porcentajes")\r\n                # print(pixeles_blancos, tamanio, porcentaje_blancos)\r\n                # if porcentaje_blancos < 0.05: #Si tengo pocos blancos me voy\r\n                #     return None\r\n\r\n\r\n                # get the convex hull\r\n                hull = cv2.convexHull(contours[0])\r\n                # get the corners\r\n                oriPoints = cv2.approxPolyDP(hull, 0.01*cv2.arcLength(hull, True), True)\r\n                if(len(oriPoints) != 4):\r\n                    # print("No es un cuadrado")\r\n                    return self.salida\r\n\r\n                else:\r\n                    # get the min value of x in oriPoints\r\n                    min_x = min(oriPoints[:,0,0])\r\n                    # get the max value of x in oriPoints\r\n                    max_x = max(oriPoints[:,0,0])\r\n                    # get the min value of y in oriPoints\r\n                    min_y = min(oriPoints[:,0,1])\r\n                    # get the max value of y in oriPoints\r\n                    max_y = max(oriPoints[:,0,1])\r\n                    #Vamos a tratar de que el cartel quede cuadrado en la transformaci\xc3\xb3n\r\n                    # Me fijo si lo agrando de ancho o de alto\r\n                    difx = max_x - min_x\r\n                    dify = max_y - min_y\r\n                    plusx=0\r\n                    plusy=0\r\n                    # calculo la mitad de lo que tengo que estirarlo, as\xc3\xad lo corro un poquito menos en el m\xc3\xadnimo y un poquito mas en m\xc3\xa1ximo\r\n                    if difx > dify:\r\n                        plusy = (difx - dify) / 2\r\n                    else:\r\n                        plusx = (dify - difx) / 2\r\n\r\n                    dstPoints = np.array([[min_x-plusx, min_y-plusy], [max_x+plusx, min_y-plusy], [max_x+plusx, max_y+plusy], [min_x-plusx, max_y+plusy]], dtype=np.float32)\r\n\r\n                    oriPoints = oriPoints.reshape(4, 2)\r\n                    oriPoints = oriPoints.astype(np.float32)\r\n\r\n                    oriPoints= utils.sortCw(oriPoints)\r\n                    dstPoints= utils.sortCw(dstPoints)\r\n                    \r\n                    minXPoint = oriPoints[0]\r\n                    maxXPoint = oriPoints[1]\r\n                    # print("Llegu\xc3\xa9 a calcular los puntos")\r\n                    M = cv2.getPerspectiveTransform(oriPoints, dstPoints)\r\n                    thresh = cv2.warpPerspective(thresh, M, (64, 64))\r\n                    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n\r\n\r\n                    # print("Qued\xc3\xb3 de ", len(contours), len(contours[0]))\r\n                    recorte=2 # cantidad de pixels que recorto de cada lado para sacar bordes negros\r\n                    # print("MinXPoint: ",minXPoint)\r\n                    # print("MaxXPoint: ",maxXPoint)\r\n            else:\r\n                pass\r\n                # print("Encontr\xc3\xb3 una letra copada sin tener que transformarla")\r\n\r\n            if len(contours) == 1 and len(contours[0]) <=40:    \r\n                \r\n                approx = cv2.minAreaRect(contours[0])\r\n                angulo = approx[2]\r\n                if angulo % 90 == 0:\r\n                    # print("Encontr\xc3\xa9 un cartel que parece una letra")\r\n                    x = int(approx[0][0])\r\n                    y = int(approx[0][1])                \r\n                    if x < 26 or x > 38:\r\n                        # print("CHAU porque x no est\xc3\xa1 en el rango", x) \r\n                        return None\r\n                    if y < 26 or y > 38: \r\n                        # print("CHAU porque y no est\xc3\xa1 en el rango")\r\n                        return None\r\n                    mitad_ancho = int(approx[1][0] / 2)-recorte\r\n                    mitad_alto = int(approx[1][1] / 2)-recorte\r\n                    \r\n                    rect = thresh[y - mitad_alto:y + mitad_alto, x - mitad_ancho:x + mitad_ancho]\r\n                    tamanio = rect.shape[0] * rect.shape[1]\r\n                    if tamanio == 0: \r\n                        # print("Me dio tama\xc3\xb1o 0")\r\n                        return None\r\n                    if abs(rect.shape[0] - rect.shape[1]) > 2:\r\n                        # print("CHAU porque no es un cuadrado")\r\n                        return None\r\n \r\n                    \r\n                    pixeles_negros = np.count_nonzero(rect == 0)\r\n                    if pixeles_negros == 0: \r\n                        # print("CHAU porque no hay pixeles negros")\r\n                        return None\r\n                    \r\n                    porcentaje_negros = pixeles_negros / tamanio\r\n                    if porcentaje_negros < 0.1:\r\n                        # print("CHAU porque hay muy pocos porcentaje de negros")\r\n                        return None\r\n                    \r\n                    \r\n                    cuadritoArriba = thresh[y - mitad_alto:y - int(mitad_alto / 3), x - int(mitad_ancho / 3):x + int(mitad_ancho / 3)]\r\n                    cuadritoAbajo = thresh[y + int(mitad_alto / 3):y + mitad_alto, x - int(mitad_ancho / 3):x + int(mitad_ancho / 3)]\r\n                    top_central = y - int(mitad_alto / 3)\r\n                    bottom_central = y + int(mitad_alto / 3)\r\n                    left_central = x - int(mitad_ancho / 3)\r\n                    right_central = x + int(mitad_ancho / 3)\r\n                    cuadritoCentral = thresh[top_central:bottom_central, left_central:right_central]\r\n                    pixeles_negros_central = np.count_nonzero(cuadritoCentral == 0)\r\n                    pixeles_negros_arriba = np.count_nonzero(cuadritoArriba == 0)\r\n                    pixeles_negros_abajo = np.count_nonzero(cuadritoAbajo == 0)\r\n\r\n                    if pixeles_negros_abajo <= 3 and pixeles_negros_arriba <= 6 and pixeles_negros_central >= 30: #ACAACA dec\xc3\xada 35 lo relajamos\r\n                        self.salida = \'H\'\r\n                    elif pixeles_negros_abajo >= 13 and pixeles_negros_arriba >= 13:\r\n                        self.salida = \'S\'\r\n                    elif pixeles_negros_abajo >= 15 and pixeles_negros_arriba <= 8: #ACAACA Antes dec\xc3\xada 5, lo relajamos\r\n                        self.salida = \'U\'\r\n                    elif pixeles_negros_abajo >= 1 and pixeles_negros_arriba >= 1:\r\n                        return self.salida\r\n                    # print("Pixeles")\r\n                    # print(pixeles_negros_arriba, pixeles_negros_central, pixeles_negros_abajo)\r\n                    # print(self.salida)\r\n                    # # Descomentar para ver si hay falsos positivos\r\n                    # self.debugShow(self.img)\r\n                    # self.debugShow(paraMostrarDespues)\r\n                    # self.debugShow(rect)\r\n            return self.salida\r\n        else:\r\n            pass\r\n            # print(len(contours))\r\n        \r\n    def reconocer_limpiar_cartel(self):\r\n        if self.img is None or self.img.size == 0:\r\n            return None\r\n        \r\n        gris = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)\r\n        _, thresh = cv2.threshold(gris, 120, 255, cv2.THRESH_BINARY)\r\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n        if len(contours) == 0:\r\n            return None\r\n        \r\n            \r\n        approx = cv2.minAreaRect(contours[0])\r\n        angulo = approx[2]\r\n        if abs(angulo)%45 == 0:\r\n            alto, ancho = thresh.shape[0], thresh.shape[1]\r\n            M = cv2.getRotationMatrix2D((ancho / 2, alto / 2), angulo, 1)\r\n            thresh_rot = cv2.warpAffine(thresh, M, (ancho, alto))\r\n            imagen_rot = cv2.warpAffine(self.img, M, (ancho, alto))\r\n            contours, _ = cv2.findContours(thresh_rot, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n            if len(contours) == 0:\r\n                return None\r\n            \r\n            x = int(approx[0][0])\r\n            y = int(approx[0][1])\r\n            mitad_ancho = int(approx[1][0] / 2)\r\n            mitad_alto = int(approx[1][1] / 2)\r\n\r\n            if y - mitad_alto < 0 or y + mitad_alto > imagen_rot.shape[0] or x - mitad_ancho < 0 or x + mitad_ancho > imagen_rot.shape[1]:\r\n                return None\r\n            rect = imagen_rot[y - mitad_alto:y + mitad_alto, x - mitad_ancho:x + mitad_ancho]\r\n            return rect, True\r\n        return None\r\n    \r\n    def devolver_letra_carteles(self):\r\n        self.salida = None\r\n        gris = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)\r\n        _, thresh = cv2.threshold(gris, 120, 255, cv2.THRESH_BINARY)\r\n        contornos, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n        if len(contornos) == 0:\r\n            return None\r\n        \r\n        area=cv2.contourArea(contornos[0])\r\n        # print("Area: ", area)\r\n        if area< 100:\r\n            return None\r\n        \r\n        approx = cv2.minAreaRect(contornos[0])\r\n        angulo = approx[2]\r\n        if abs(angulo) == 45:\r\n            alto, ancho = thresh.shape[0], thresh.shape[1]\r\n            M = cv2.getRotationMatrix2D((ancho / 2, alto / 2), angulo, 1)\r\n            thresh_rot = cv2.warpAffine(thresh, M, (ancho, alto))\r\n            imagen_rot = cv2.warpAffine(self.img, M, (ancho, alto))\r\n            contornos, _ = cv2.findContours(thresh_rot, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n            if len(contornos) == 0:\r\n                return None\r\n            \r\n            x = int(approx[0][0])\r\n            y = int(approx[0][1])\r\n            \r\n            if x < 26 or x > 38: return None\r\n            if y < 26 or y > 38: return None\r\n\r\n            mitadAncho = int(approx[1][0] / 2)\r\n            mitadAlto = int(approx[1][1] / 2)\r\n            \r\n            if y - mitadAlto < 0 or y + mitadAlto > imagen_rot.shape[0] or x - mitadAncho < 0 or x + mitadAncho > imagen_rot.shape[1]:\r\n                return None\r\n            rect = imagen_rot[y - mitadAlto:y + mitadAlto, x - mitadAncho:x + mitadAncho]\r\n            \r\n            tamanio = rect.shape[0] * rect.shape[1]\r\n            if tamanio == 0: return None\r\n                       \r\n            if abs(rect.shape[0] - rect.shape[1]) > 2:\r\n                #print("CHAU porque no es un cuadrado")\r\n                return None\r\n\r\n            amarillo, rojo, negro, blanco = 0, 0, 0, 0\r\n            for x in range(rect.shape[0]):\r\n                for y in range(rect.shape[1]):\r\n                    pixel = rect[x, y]\r\n                    b, g, r = pixel[:3]\r\n                    if b > 200 and g > 200 and r > 200:\r\n                        blanco += 1\r\n                    elif b <= 1 and g <= 1 and r <= 1:\r\n                        negro += 1\r\n                    elif b > 70 and g < 5 and r > 190:\r\n                        rojo += 1\r\n                    elif b < 10 and g > 190 and r > 195:\r\n                        amarillo += 1\r\n            if rojo > 0 and rojo > blanco and rojo > negro and rojo > amarillo and blanco == 0 and negro == 0 and amarillo == 0:\r\n                self.salida = \'F\'\r\n            elif (blanco + negro) > (amarillo + rojo) and blanco > negro:\r\n                self.salida = \'P\'\r\n            elif (blanco + negro) > (amarillo + rojo):\r\n                self.salida = \'C\'\r\n            elif rojo > 0 and amarillo > 0 and rojo > blanco and rojo > negro and rojo > amarillo and amarillo > blanco and amarillo > negro:\r\n                self.salida = \'O\'\r\n            return self.salida\r\n        \r\n    def procesar(self, converted_img):\r\n        # if converted_img is None or converted_img.size == 0:\r\n        #     return None\r\n        self.img = converted_img\r\n        victima = self.devolver_letra_victimas()\r\n        if victima is not None:\r\n            #print(\'letra\', victima)\r\n            return victima\r\n        else:\r\n            cartel = self.reconocer_limpiar_cartel()\r\n            if cartel is not None:\r\n                salida = self.devolver_letra_carteles()\r\n                #print(\'cartel\', salida)\r\n                return salida\r\n        return None\r\n    \r\n    def see_hole(self, img):\r\n        gris = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n        mitad = gris[43:, :]\r\n        tamanio = mitad.shape[0] * mitad.shape[1]\r\n        pixeles_negros = np.count_nonzero(mitad < 31)\r\n        porcentaje_negros = pixeles_negros / tamanio\r\n        black_Hole = False\r\n        if porcentaje_negros >=0.85 and porcentaje_negros <= 0.97:\r\n            black_Hole = True\r\n        return black_Hole\r\n')
    __stickytape_write_module('utils.py', b'import math\r\nfrom point import Point\r\nimport numpy as np\r\n\r\ndef angle_diff(a, b):\r\n    clockwise = (a - b) % math.tau\r\n    counterclockwise = (b - a) % math.tau\r\n    return min(clockwise, counterclockwise)\r\n\r\ndef targetPoint(position, angle, distance):\r\n    angle+=math.pi/2\r\n    x = position.x + distance * math.cos(angle)\r\n    y = position.y - distance * math.sin(angle)\r\n    return Point(x, y)\r\n\r\ndef puntoEnBordeY(origRobot, puntoAAveriguar):\r\n    aux=puntoAAveriguar.y-(origRobot.y-0.06)\r\n    return near_multiple(aux, 0.12, 0.0025)\r\n \r\ndef puntoEnBordeX(origRobot, puntoAAveriguar):\r\n    aux=puntoAAveriguar.x-(origRobot.x-0.06)\r\n    return near_multiple(aux, 0.12, 0.0025)\r\n\r\ndef near_multiple(num, base=0.12, tolerance=1e-6):\r\n    # Encuentra el m\xc3\xbaltiplo m\xc3\xa1s cercano de la base\r\n    closestMultiple = round(num / base) * base\r\n    # Verifica si la diferencia es menor que la tolerancia\r\n    return abs(num - closestMultiple) < tolerance\r\n\r\ndef sortCw(listPoints):\r\n    listAux=listPoints.copy()\r\n    # Ordena los puntos en sentido horario\r\n    aux=[]\r\n    sumMin=1000\r\n    primero=0\r\n    for i in range(4):\r\n        sumPoints=listAux[i][0]+listAux[i][1]\r\n        if sumPoints<sumMin:\r\n            sumMin=sumPoints\r\n            primero=i\r\n    # remove an element of numpy array\r\n    pos1=listAux[primero]\r\n    listAux=np.delete(listAux, primero, axis=0)\r\n\r\n    sumMax=-10000\r\n    tercero=0\r\n    for i in range(3):\r\n        sumPoints=listAux[i][0]+listAux[i][1]\r\n        if sumPoints>sumMax:\r\n            sumMax=sumPoints\r\n            tercero=i\r\n    pos3=listAux[tercero]\r\n    listAux=np.delete(listAux, tercero, axis=0)\r\n\r\n    if listAux[0][0]>listAux[1][0]:\r\n        pos2=listAux[0]\r\n        pos4=listAux[1]\r\n    else:\r\n        pos2=listAux[1]\r\n        pos4=listAux[0]\r\n    return np.array([pos1, pos2, pos3, pos4],dtype=np.float32)')
    __stickytape_write_module('piso.py', b'class Piso:\r\n    def __init__(self, r, g, b):\r\n        self.redValue = r\r\n        self.greenValue = g\r\n        self.blueValue = b\r\n    def pantano(self):\r\n        return abs(self.redValue - 169) < 15 \\\r\n            and abs(self.greenValue - 135) < 15 \\\r\n            and abs(self.blueValue - 75) < 15\r\n    def blackHole(self):\r\n        return abs(self.redValue) < 35 \\\r\n            and abs(self.greenValue) < 35 \\\r\n            and abs(self.blueValue) < 35\r\n    def green(self):\r\n        return abs(self.redValue - 25) < 15 \\\r\n            and abs(self.greenValue - 227) < 15 \\\r\n            and abs(self.blueValue - 25) < 15\r\n    def yellow(self):\r\n        return abs(self.redValue - 234) < 15 \\\r\n            and abs(self.greenValue - 234) < 15 \\\r\n            and abs(self.blueValue - 47) < 15\r\n    def red(self):\r\n        return abs(self.redValue - 234) < 15 \\\r\n            and abs(self.greenValue - 47) < 15 \\\r\n            and abs(self.blueValue - 47) < 15\r\n\r\n    def blue(self):\r\n        return abs(self.redValue - 47) <10 \\\r\n            and abs(self.greenValue - 47) < 10 \\\r\n            and abs(self.blueValue - 234) < 10\r\n\r\n    def purple(self):\r\n        return abs(self.redValue - 109) < 15 \\\r\n            and abs(self.greenValue - 47) < 15 \\\r\n            and abs(self.blueValue - 188) < 15\r\n\r\n    def estandar(self):\r\n        return abs(self.redValue - 195) < 2 \\\r\n            and abs(self.greenValue - 195) < 2 \\\r\n            and abs(self.blueValue - 195) < 2\r\n\r\n    def checkpoint(self):\r\n        # return abs(self.redValue - 70) < 15 \\\r\n        #     and abs(self.greenValue - 75) < 15 \\\r\n        #     and abs(self.blueValue - 90) < 15\r\n        # return (abs(self.redValue - 42) < 20 \\\r\n        #     and abs(self.greenValue - 47) < 20 \\\r\n        #     and abs(self.blueValue - 64) < 20) or (abs(self.redValue - 73) < 5 \\\r\n        #                                            and abs(self.greenValue - 78) < 5 \\\r\n        #                                             and abs(self.blueValue - 94) < 5)\r\n        difRedGreen=abs(self.redValue-self.greenValue)\r\n        difRedBlue=abs(self.redValue-self.blueValue)\r\n        if abs(difRedGreen-5)<4 and (difRedBlue-21)<4:\r\n            return True\r\n    \r\n    def orange(self):\r\n        return abs(self.redValue - 234) < 15 \\\r\n            and abs(self.greenValue - 188) < 15 \\\r\n            and abs(self.blueValue - 47) < 15')
    __stickytape_write_module('lidar.py', b'import math\r\n\r\nclass Lidar:\r\n    shift ={\'N\': 0, \'E\': 384, \'S\': 256, \'W\':128}\r\n\r\n    rays_1 ={0:[210, 0.095, 0.12],1:[210, 0.06, 0.08], 2:[256, 0.05, 0.075], 3:[302, 0.06, 0.08],\\\r\n            4: [302, 0.095, 0.12], 5: [338, 0.095, 0.12], 6:[338,0.06, 0.085], 7:[384,0.045, 0.075], \\\r\n            8:[430,0.06, 0.085],9:[430,0.095, 0.12],10:[466,0.095, 0.12],11:[466,0.06, 0.085], 12:[0,0.05, 0.075], \\\r\n            13:[46,0.06, 0.085], 14:[46,0.095, 0.12], 15:[82,0.095, 0.12], 16:[82,0.06, 0.085], 17:[128,0.045, 0.075], \\\r\n            18:[174,0.06, 0.085], 19:[174,0.095, 0.12]}\r\n    """rays_1 ={0:[210, 0.095, 0.12],1:[210, 0.06, 0.08], 2:[256, 0.05, 0.075], 3:[299, 0.06, 0.08],\\\r\n            4: [302, 0.095, 0.12], 5: [338, 0.095, 0.12], 6:[338, 0.06,], 7:[0, 0,0], \\\r\n            8:[43, 0.06, 0.08],9:[86,0.057, 0.08],10:[128,0,0],11:[171,0.057, 0.08]}"""\r\n    \r\n    rays_2 ={0: [230,0.112, 0.1354], 1: [256, 0.05, 0.075], 2: [282,0.112, 0.1354], 3:[302,0.095, 0.12], 4:[302,0.06, 0.085], 5:[340,0.057, 0.077], 6:[428,0.057, 0.077],\\\r\n            7:[466,0.06, 0.085], 8:[466,0.095, 0.12], 9:[486,0.112, 0.1354], 10:[0,0.05, 0.075], 11:[26,0.112, 0.1354], 12:[46,0.095, 0.12], 13:[46,0.06, 0.085],\\\r\n            14:[84,0.057, 0.077], 15:[172,0.057, 0.077], 16:[210,0.06, 0.085], 17:[210,0.095, 0.12]}\r\n    \r\n    rays_3 ={0: [174,0.095, 0.12], 1: [174,0.06, 0.085], 2: [212,0.057, 0.077], 3:[300,0.057, 0.077], 4:[338,0.06, 0.085], 5:[338,0.095, 0.12], 6:[358,0.112, 0.135],\\\r\n            7:[384,0.045, 0.075], 8:[410,0.112, 0.135], 9:[430,0.095, 0.12], 10:[430,0.06, 0.085], 11:[468,0.057, 0.077], 12:[44,0.057, 0.077], 13:[82,0.06, 0.085],\\\r\n            14:[82,0.095, 0.12], 15:[102,0.112, 0.1354], 16:[128,0.045, 0.075], 17:[154,0.112, 0.135]}\r\n    \r\n    rays_4 = {0: [205, 0.13, 0.16], 1: [205, 0.087, 0.12], 2: [235, 0.112, 0.1354], 3: [256, 0.045, 0.075], 4: [277, 0.112, 0.1354], \\\r\n              5: [307, 0.087, 0.12], 6: [307, 0.13, 0.16], 7: [333, 0.13, 0.16], 8: [333, 0.085, 0.12], 9: [363, 0.112, 0.135], \\\r\n              10: [384, 0.045, 0.075], 11: [405, 0.112, 0.135], 12: [435, 0.085, 0.12], 13: [435, 0.13, 0.16], 14: [461, 0.13, 0.16],\\\r\n              15: [461, 0.087, 0.12], 16: [491, 0.112, 0.1354], 17: [0, 0.045, 0.075], 18: [21, 0.112, 0.1354], 19: [51, 0.087, 0.12], \\\r\n              20: [51, 0.13, 0.16], 21: [77, 0.13, 0.16], 22: [77, 0.085, 0.12], 23: [107, 0.112, 0.135], 24: [128, 0.045, 0.075], \\\r\n              25: [149, 0.112, 0.135], 26: [179, 0.085, 0.12], 27: [179, 0.13, 0.16], 28: [235, 0.05, 0.077], 29: [277, 0.05, 0.077],\\\r\n              30: [363, 0.05, 0.075], 31: [405, 0.05, 0.075], 32: [491, 0.05, 0.077], 33: [21, 0.05, 0.077], 34: [107,0.05, 0.075],\\\r\n              35: [149,0.05, 0.075]}\r\n    \r\n    def __init__(self, lidar, time_step):\r\n        self.lidar = lidar\r\n        self.lidar.enable(time_step)\r\n        self.rangeImage = None\r\n    \r\n    def update(self):\r\n        self.rangeImage = self.lidar.getRangeImage()[1024:1536]\r\n\r\n    def isOpenNorth(self, orient):\r\n        lidar_idx = {\'N\': 256,\r\n                     \'W\': 384,\r\n                     \'S\': 0,\r\n                     \'E\': 128}\r\n        \r\n        dist = self.rangeImage[lidar_idx[orient]]\r\n        return dist >= 0.08\r\n    \r\n    def isOpenSouth(self, orient):\r\n        lidar_idx = {\'S\': 256,\r\n                     \'E\': 384,\r\n                     \'N\': 0,\r\n                     \'W\': 128}\r\n        \r\n        dist = self.rangeImage[lidar_idx[orient]]\r\n        return dist >= 0.08\r\n\r\n    def isOpenWest(self, orient):\r\n        lidar_idx = {\'S\': 384,\r\n                     \'E\': 0,\r\n                     \'N\': 128,\r\n                     \'W\': 256}\r\n        \r\n        dist = self.rangeImage[lidar_idx[orient]]\r\n        return dist >= 0.08\r\n    \r\n    def isOpenEast(self, orient):\r\n        lidar_idx = {\'S\': 128,\r\n                     \'E\': 256,\r\n                     \'N\': 384,\r\n                     \'W\': 0}\r\n        \r\n        dist = self.rangeImage[lidar_idx[orient]]\r\n        return dist >= 0.08\r\n    \r\n    def ver_walls(self, rotation): # caso 4\r\n        shift = self.rotToLidar(rotation)\r\n        # gira los rayos para que est\xc3\xa9n en orientaci\xc3\xb3n Norte\r\n        rangeLocal = self.rangeImage[shift:] + self.rangeImage[:shift]\r\n        walls = {}\r\n        for i in self.rays_4.keys():\r\n            walls[i]=(rangeLocal[self.rays_4[i][0]])\r\n        return walls\r\n\r\n    def get_walls_1(self, rotation):\r\n        shift = self.rotToLidar(rotation)\r\n        # gira los rayos para que est\xc3\xa9n en orientaci\xc3\xb3n Norte\r\n        rangeLocal = self.rangeImage[shift:] + self.rangeImage[:shift]\r\n        # create a dictionary with the walls\r\n        walls = {}\r\n        for i in self.rays_1.keys():\r\n            ray=self.rays_1[i][0]\r\n            rayDistance=rangeLocal[ray]\r\n            lowerLimit=self.rays_1[i][1]\r\n            upperLimit=self.rays_1[i][2]\r\n\r\n            if rayDistance>=lowerLimit and rayDistance<=upperLimit:\r\n                walls[i]=1\r\n                # walls[i]=(1, lowerLimit,upperLimit,rayDistance)\r\n            elif rayDistance<lowerLimit:\r\n                walls[i]=-1\r\n                # walls[i]=(-1,lowerLimit,upperLimit,rayDistance)\r\n            else:\r\n                walls[i]=0\r\n                # walls[i]=(0,lowerLimit,upperLimit,rayDistance)\r\n        if walls[3] == 1:\r\n            walls[2] = -1\r\n            walls[4] = -1\r\n        if walls[1] == 1:\r\n            walls[0] = -1\r\n            walls[2] = -1\r\n        if walls[6] == 1:\r\n            walls[5] = -1\r\n            walls[7] = -1\r\n        if walls[8] == 1:\r\n            walls[7] = -1\r\n            walls[9] = -1\r\n        if walls[11] == 1:\r\n            walls[10] = -1\r\n            walls[12] = -1\r\n        if walls[13] == 1:\r\n            walls[12] = -1\r\n            walls[14] = -1\r\n        if walls[16] == 1:\r\n            walls[15] = -1\r\n            walls[17] = -1\r\n        if walls[18] == 1:\r\n            walls[17] = -1\r\n            walls[19] = -1\r\n            #walls.append(rangeLocal[self.rays_1[i][0]])\r\n        return walls\r\n    \r\n    def updateWalls1(self, rotation, map, tile):\r\n        walls = self.get_walls_1(rotation)\r\n\r\n        self.setWall(tile.north, 0, walls[1])\r\n        self.setWall(tile.north, 1, 0)\r\n        self.setWall(tile.north, 2, walls[3])\r\n\r\n        self.setWall(tile.east, 0, walls[6])\r\n        self.setWall(tile.east, 1, 0)\r\n        self.setWall(tile.east, 2, walls[8])\r\n\r\n        self.setWall(tile.south, 0, walls[11])\r\n        self.setWall(tile.south, 1, 0)\r\n        self.setWall(tile.south, 2, walls[13])\r\n\r\n        self.setWall(tile.west, 0, walls[16])\r\n        self.setWall(tile.west, 1, 0)\r\n        self.setWall(tile.west, 2, walls[18])\r\n\r\n        north_tile = tile.getNorthTile()\r\n        east_tile = tile.getEastTile()\r\n        west_tile = tile.getWestTile()\r\n        south_tile = tile.getSouthTile()\r\n\r\n        self.setWall(north_tile.west, 0, walls[0])\r\n\r\n        self.setWall(north_tile.south, 0, walls[3])\r\n        self.setWall(north_tile.south, 1, walls[2])\r\n        self.setWall(north_tile.south, 2, walls[1])\r\n\r\n        self.setWall(north_tile.east, 2, walls[4])\r\n\r\n        self.setWall(east_tile.north, 0, walls[5])\r\n\r\n        self.setWall(east_tile.west, 0, walls[8])\r\n        self.setWall(east_tile.west, 1, walls[7])\r\n        self.setWall(east_tile.west, 2, walls[6])\r\n\r\n        self.setWall(east_tile.south, 2, walls[9])\r\n\r\n        self.setWall(south_tile.east, 0, walls[10])\r\n\r\n        self.setWall(south_tile.north, 0, walls[13])\r\n        self.setWall(south_tile.north, 1, walls[12])\r\n        self.setWall(south_tile.north, 2, walls[11])\r\n\r\n        self.setWall(south_tile.west, 2, walls[14])\r\n        \r\n        self.setWall(west_tile.south, 0, walls[15])\r\n\r\n        self.setWall(west_tile.east, 0, walls[18])\r\n        self.setWall(west_tile.east, 1, walls[17])\r\n        self.setWall(west_tile.east, 2, walls[16])\r\n\r\n        self.setWall(west_tile.north, 2, walls[19])\r\n\r\n        self.fixNeighbours(tile)\r\n        self.fixNeighbours(north_tile)\r\n        self.fixNeighbours(south_tile)\r\n        self.fixNeighbours(east_tile)\r\n        self.fixNeighbours(west_tile)\r\n    \r\n    def get_walls_2(self, rotation):\r\n        shift = self.rotToLidar(rotation)\r\n        # gira los rayos para que est\xc3\xa9n en orientaci\xc3\xb3n Norte\r\n        rangeLocal = self.rangeImage[shift:] + self.rangeImage[:shift]\r\n        walls = {}\r\n        for i in self.rays_2.keys():\r\n            ray=self.rays_2[i][0]\r\n            rayDistance=rangeLocal[ray]\r\n            lowerLimit=self.rays_2[i][1]\r\n            upperLimit=self.rays_2[i][2]\r\n            if rayDistance>=lowerLimit and rayDistance<=upperLimit:\r\n                walls[i]=1\r\n                # walls[i]=(1, lowerLimit,upperLimit,rayDistance)\r\n            elif rayDistance<lowerLimit:\r\n                walls[i]=-1\r\n                # walls[i]=(-1,lowerLimit,upperLimit,rayDistance)\r\n            else:\r\n                walls[i]=0\r\n                # walls[i]=(0,lowerLimit,upperLimit,rayDistance)\r\n        if walls[4]==1:\r\n            walls[1]=-1\r\n            walls[2]=-1\r\n            walls[3]=-1\r\n        if walls[7]==1:\r\n            walls[8]=-1\r\n            walls[9]=-1\r\n            walls[10]=-1\r\n        if walls[13]==1:\r\n            walls[10]=-1\r\n            walls[11]=-1\r\n            walls[12]=-1\r\n        if walls[16]==1:\r\n            walls[17]=-1\r\n            walls[0]=-1\r\n            walls[1]=-1    \r\n        return walls\r\n\r\n    def updateWalls2(self, rotation, map, tiles):\r\n        walls = self.get_walls_2(rotation)\r\n        north_tile = None\r\n        south_tile = None\r\n        if tiles[0].row < tiles[1].row:\r\n            north_tile = tiles[0]\r\n            south_tile = tiles[1]\r\n        else:\r\n            north_tile = tiles[1]\r\n            south_tile = tiles[0]\r\n\r\n        self.setWall(north_tile.north, 0, walls[0])\r\n        self.setWall(north_tile.north, 1, walls[1])\r\n        self.setWall(north_tile.north, 2, walls[2])\r\n\r\n        self.setWall(north_tile.east, 0, walls[3])\r\n        self.setWall(north_tile.east, 1, walls[4])\r\n        self.setWall(north_tile.east, 2, walls[5])\r\n\r\n        north_tile.south = [0, 0, 0]\r\n\r\n        self.setWall(north_tile.west, 0, walls[15])\r\n        self.setWall(north_tile.west, 1, walls[16])\r\n        self.setWall(north_tile.west, 2, walls[17])\r\n\r\n        south_tile.north = [0, 0, 0]\r\n\r\n        self.setWall(south_tile.east, 0, walls[6])\r\n        self.setWall(south_tile.east, 1, walls[7])\r\n        self.setWall(south_tile.east, 2, walls[8])\r\n\r\n        self.setWall(south_tile.south, 0, walls[9])\r\n        self.setWall(south_tile.south, 1, walls[10])\r\n        self.setWall(south_tile.south, 2, walls[11])\r\n\r\n        self.setWall(south_tile.west, 0, walls[12])\r\n        self.setWall(south_tile.west, 1, walls[13])\r\n        self.setWall(south_tile.west, 2, walls[14])\r\n\r\n        self.fixNeighbours(north_tile)\r\n        self.fixNeighbours(south_tile)\r\n        \r\n    def get_walls_3(self, rotation):\r\n        shift = self.rotToLidar(rotation)\r\n        # gira los rayos para que est\xc3\xa9n en orientaci\xc3\xb3n Norte\r\n        rangeLocal = self.rangeImage[shift:] + self.rangeImage[:shift]\r\n        walls = {}\r\n        for i in self.rays_3.keys():\r\n            ray=self.rays_3[i][0]\r\n            rayDistance=rangeLocal[ray]\r\n            lowerLimit=self.rays_3[i][1]\r\n            upperLimit=self.rays_3[i][2]\r\n            if rayDistance>=lowerLimit and rayDistance<=upperLimit:\r\n                walls[i]= 1\r\n                # walls[i]=(1, lowerLimit,upperLimit,rayDistance)\r\n            elif rayDistance<lowerLimit:\r\n                walls[i]= -1\r\n                # walls[i]=(-1,lowerLimit,upperLimit,rayDistance)\r\n            else:\r\n                walls[i]= 0\r\n                # walls[i]=(0,lowerLimit,upperLimit,rayDistance)\r\n        if walls[1]==1:\r\n            walls[0]=-1\r\n            walls[16]=-1\r\n            walls[17]=-1\r\n        if walls[4]==1:\r\n            walls[5]=-1\r\n            walls[6]=-1\r\n            walls[7]=-1\r\n        if walls[10]==1:\r\n            walls[7]=-1\r\n            walls[8]=-1\r\n            walls[9]=-1\r\n        if walls[13]==1:\r\n            walls[14]=-1\r\n            walls[15]=-1\r\n            walls[16]=-1\r\n        return walls\r\n    \r\n    def updateWalls3(self, rotation, map, tiles):        \r\n        walls = self.get_walls_3(rotation)\r\n        \r\n        west_tile = None\r\n        east_tile = None\r\n        if tiles[0].col < tiles[1].col:\r\n            west_tile = tiles[0]\r\n            east_tile = tiles[1]\r\n        else:\r\n            west_tile = tiles[1]\r\n            east_tile = tiles[0]\r\n\r\n        self.setWall(west_tile.north, 0, walls[0])\r\n        self.setWall(west_tile.north, 1, walls[1])\r\n        self.setWall(west_tile.north, 2, walls[2])\r\n\r\n        west_tile.east = [0, 0, 0]\r\n\r\n        self.setWall(west_tile.south, 0, walls[12])\r\n        self.setWall(west_tile.south, 1, walls[13])\r\n        self.setWall(west_tile.south, 2, walls[14])\r\n\r\n        self.setWall(west_tile.west, 0, walls[15])\r\n        self.setWall(west_tile.west, 1, walls[16])\r\n        self.setWall(west_tile.west, 2, walls[17])\r\n\r\n        self.setWall(east_tile.north, 0, walls[3])\r\n        self.setWall(east_tile.north, 1, walls[4])\r\n        self.setWall(east_tile.north, 2, walls[5])\r\n        \r\n        self.setWall(east_tile.east, 0, walls[6])\r\n        self.setWall(east_tile.east, 1, walls[7])\r\n        self.setWall(east_tile.east, 2, walls[8])\r\n\r\n        self.setWall(east_tile.south, 0, walls[9])\r\n        self.setWall(east_tile.south, 1, walls[10])\r\n        self.setWall(east_tile.south, 2, walls[11])\r\n\r\n        east_tile.west = [0, 0, 0]\r\n\r\n        self.fixNeighbours(west_tile)\r\n        self.fixNeighbours(east_tile)\r\n    \r\n    def get_walls_4(self, rotation):\r\n        # print(self.ver_walls(rotation))\r\n        shift = self.rotToLidar(rotation)\r\n        rangeLocal = self.rangeImage[shift:] + self.rangeImage[:shift]\r\n        walls = {}\r\n        for i in self.rays_4.keys():\r\n            ray=self.rays_4[i][0]\r\n            rayDistance=rangeLocal[ray]\r\n            lowerLimit=self.rays_4[i][1]\r\n            upperLimit=self.rays_4[i][2]\r\n            if rayDistance>=lowerLimit and rayDistance<=upperLimit:\r\n                walls[i]= 1\r\n            elif rayDistance<lowerLimit:\r\n                walls[i]= -1\r\n            else:\r\n                walls[i]= 0\r\n        if walls[1] == 1:\r\n            walls[0] = -1\r\n        if walls[28] == 1:\r\n            walls[0] = -1\r\n            walls[1] = -1\r\n            walls[2] = -1\r\n            walls[3] = -1\r\n        if walls[29] == 1:\r\n            walls[3] = -1\r\n            walls[4] = -1\r\n            walls[5] = -1\r\n            walls[6] = -1\r\n        if walls[30] == 1:\r\n            walls[10] = -1\r\n            walls[7] = -1\r\n            walls[8] = -1\r\n            walls[9] = -1\r\n        if walls[31] == 1:\r\n            walls[10] = -1\r\n            walls[11] = -1\r\n            walls[12] = -1\r\n            walls[13] = -1\r\n        if walls[32] == 1:\r\n            walls[16] = -1\r\n            walls[17] = -1\r\n            walls[14] = -1\r\n            walls[15] = -1\r\n        if walls[33] == 1:\r\n            walls[17] = -1\r\n            walls[18] = -1\r\n            walls[19] = -1\r\n            walls[20] = -1\r\n        if walls[34] == 1:\r\n            walls[21] = -1\r\n            walls[22] = -1\r\n            walls[23] = -1\r\n            walls[24] = -1\r\n        if walls[35] == 1:\r\n            walls[24] = -1\r\n            walls[25] = -1\r\n            walls[26] = -1\r\n            walls[27] = -1\r\n        if walls[8] == 1:\r\n            walls[7] = -1\r\n        if walls[12] == 1:\r\n            walls[13] = -1\r\n        if walls[15] == 1:\r\n            walls[14] = -1\r\n        if walls[19] == 1:\r\n            walls[20] = -1\r\n        if walls[22] == 1:\r\n            walls[21] = -1\r\n        if walls[26] == 1:\r\n            walls[27] = -1\r\n        return walls\r\n        \r\n    def updateWalls4(self, rotation, map, tiles):\r\n        walls = self.get_walls_4(rotation)\r\n\r\n        min_col = math.inf\r\n        min_row = math.inf\r\n        for t in tiles:\r\n            if t.col < min_col: min_col = t.col\r\n            if t.row < min_row: min_row = t.row\r\n\r\n        nw_tile = map.getTileAt(min_col, min_row)\r\n        ne_tile = map.getTileAt(min_col + 1, min_row)\r\n        sw_tile = map.getTileAt(min_col, min_row + 1)\r\n        se_tile = map.getTileAt(min_col + 1, min_row + 1)\r\n\r\n        self.setWall(nw_tile.north, 0, walls[0])        \r\n        self.setWall(nw_tile.north, 1, walls[1])\r\n        self.setWall(nw_tile.north, 2, walls[2])\r\n\r\n        self.setWall(nw_tile.east, 0, walls[3])\r\n        self.setWall(nw_tile.east, 1, walls[28])\r\n        self.setWall(nw_tile.east, 2, 0)\r\n\r\n        self.setWall(nw_tile.south, 0, 0)\r\n        self.setWall(nw_tile.south, 1, walls[35])\r\n        self.setWall(nw_tile.south, 2, walls[24])\r\n\r\n        self.setWall(nw_tile.west, 0, walls[25])\r\n        self.setWall(nw_tile.west, 1, walls[26])\r\n        self.setWall(nw_tile.west, 2, walls[27])\r\n\r\n        self.setWall(ne_tile.north, 0, walls[4])\r\n        self.setWall(ne_tile.north, 1, walls[5])\r\n        self.setWall(ne_tile.north, 2, walls[6])\r\n\r\n        self.setWall(ne_tile.east, 0, walls[7])\r\n        self.setWall(ne_tile.east, 1, walls[8])\r\n        self.setWall(ne_tile.east, 2, walls[9])\r\n\r\n        self.setWall(ne_tile.south, 0, walls[10]) #repite\r\n        self.setWall(ne_tile.south, 1, walls[30])\r\n        self.setWall(ne_tile.south, 2, 0)\r\n\r\n        self.setWall(ne_tile.west, 0, 0) \r\n        self.setWall(ne_tile.west, 1, walls[29])\r\n        self.setWall(ne_tile.west, 2, walls[3]) #repite\r\n\r\n        self.setWall(sw_tile.north, 0, walls[24])\r\n        self.setWall(sw_tile.north, 1, walls[34])\r\n        self.setWall(sw_tile.north, 2, 0)\r\n\r\n        self.setWall(sw_tile.east, 0, 0)\r\n        self.setWall(sw_tile.east, 1, walls[33])\r\n        self.setWall(sw_tile.east, 2, walls[17])\r\n\r\n        self.setWall(sw_tile.south, 0, walls[18])\r\n        self.setWall(sw_tile.south, 1, walls[19])\r\n        self.setWall(sw_tile.south, 2, walls[20])\r\n\r\n        self.setWall(sw_tile.west, 0, walls[21])\r\n        self.setWall(sw_tile.west, 1, walls[22])\r\n        self.setWall(sw_tile.west, 2, walls[23])\r\n\r\n        self.setWall(se_tile.north, 0, 0)\r\n        self.setWall(se_tile.north, 1, walls[31])\r\n        self.setWall(se_tile.north, 2, walls[10])\r\n\r\n        self.setWall(se_tile.east, 0, walls[11])\r\n        self.setWall(se_tile.east, 1, walls[12])\r\n        self.setWall(se_tile.east, 2, walls[13])\r\n\r\n        self.setWall(se_tile.south, 0, walls[14])\r\n        self.setWall(se_tile.south, 1, walls[15])\r\n        self.setWall(se_tile.south, 2, walls[16])\r\n\r\n        self.setWall(se_tile.west, 0, walls[17]) #repite\r\n        self.setWall(se_tile.west, 1, walls[32])\r\n        self.setWall(se_tile.west, 2, 0)\r\n\r\n        self.fixNeighbours(nw_tile)\r\n        self.fixNeighbours(ne_tile)\r\n        self.fixNeighbours(sw_tile)\r\n        self.fixNeighbours(se_tile)\r\n\r\n    def setWall(self, tile_wall, idx, value):\r\n        if value < 0: return \r\n        \r\n        # si ya hay un 1 o un 0, en una pared, confiamos en el valor que ya tiene (Gonzalo)\r\n        # if tile_wall[idx] == 0 and value != 0:\r\n        #     print("VEO PARED DONDE ANTES NO VEIA")\r\n        # if tile_wall[idx] == 1 and value != 1:\r\n        #     print("NO VEO PARED DONDE ANTES SI VEIA")\r\n            \r\n        tile_wall[idx] = value \r\n\r\n    def fixNeighbours(self, tile):\r\n        if tile.north[0] != -1:\r\n            tile.getNorthTile().south[2] = tile.north[0]\r\n        if tile.north[2] != -1:\r\n            tile.getNorthTile().south[0] = tile.north[2]\r\n        if tile.east[0] != -1:\r\n            tile.getEastTile().west[2] = tile.east[0]\r\n        if tile.east[2] != -1:\r\n            tile.getEastTile().west[0] = tile.east[2]\r\n        if tile.west[0] != -1:\r\n            tile.getWestTile().east[2] = tile.west[0]\r\n        if tile.west[2] != -1:\r\n            tile.getWestTile().east[0] = tile.west[2]\r\n        if tile.south[0] != -1:\r\n            tile.getSouthTile().north[2] = tile.south[0]\r\n        if tile.south[2] != -1:\r\n            tile.getSouthTile().north[0] = tile.south[2]\r\n\r\n    def rotToLidar(self, rot):\r\n        #Cu\xc3\xa1nto girar los rayos para tomar referencia norte\r\n        return int((256/math.pi)*rot)%512\r\n    \r\n    def hayAlgoIzquierda(self):\r\n        leftDist = self.rangeImage[128]\r\n        return leftDist < 0.08\r\n\r\n    def hayAlgoDerecha(self):\r\n        rightDist = self.rangeImage[128*3]\r\n        return rightDist < 0.08\r\n\r\n    def getNearestObstacle(self):\r\n        threshold = 0.05\r\n        min_dist = math.inf\r\n        min_ray = None\r\n        # Si achicamos el offset corremos el riesgo de quedarnos trabados por un \r\n        # obst\xc3\xa1culo, mejor ser conservador...\r\n        offset = 60\r\n        for ray_idx in range(256-offset, 257+offset):\r\n            dist = self.rangeImage[ray_idx]\r\n            if dist < threshold and dist < min_dist:\r\n                min_dist = dist\r\n                min_ray = ray_idx\r\n        return (min_ray, min_dist)\r\n            ')
    __stickytape_write_module('navigator.py', b'from map import Tile, TileType\r\nfrom point import Point\r\nfrom rectangle import Rectangle\r\nfrom collections import deque \r\nfrom dataclasses import dataclass\r\nimport time\r\n\r\n@dataclass(frozen=True)\r\nclass Movement:\r\n    start : tuple[int, int] \r\n    dest : tuple[int, int]\r\n\r\nclass Navigator:\r\n    def __init__(self, robot) -> None:\r\n        self._robot = robot\r\n        self.blockedPaths = set()\r\n        self.minitiles = {} # (c,r) -> visits\r\n        self.obstructed = set()\r\n\r\n    def addBlockedPath(self, start, dest):\r\n        start_coords = self.positionToMiniGrid(start)\r\n        dest_coords = self.positionToMiniGrid(dest)\r\n        movement = Movement(start_coords, dest_coords)\r\n        self.blockedPaths.add(movement)\r\n\r\n    def positionToMiniGrid(self, pos): \r\n        half_width = Tile.WIDTH/2\r\n        half_height = Tile.HEIGHT/2\r\n\r\n        columna = round((pos.x - self._robot.posicion_inicial.x) / half_width)\r\n        fila = round((pos.y - self._robot.posicion_inicial.y) / half_height)\r\n        return (columna, fila)\r\n\r\n    def isObstructed(self, minitile):\r\n        if minitile in self.minitiles: \r\n            return False\r\n        if minitile in self.obstructed:\r\n            return True\r\n        \r\n        minitile_pos = self.getPosition(minitile)\r\n        rect = self.getRectangle(minitile_pos)\r\n        tiles = self._robot.map.getTilesIntersecting(rect)\r\n\r\n        for tile in tiles:\r\n            if tile.dangerous or tile.type == TileType.BLACK_HOLE or not tile.isOpenAt(minitile_pos):\r\n                self.obstructed.add(minitile)\r\n                return True\r\n            \r\n        for obstacle in self._robot.map.obstacles:\r\n            obstacle_rect = self._robot.map.getObstacleRectangle(obstacle)\r\n            if obstacle_rect.intersects(rect):\r\n                self.obstructed.add(minitile)\r\n                return True\r\n            \r\n        return False\r\n            \r\n    def getPosition(self, minitile):\r\n        c = minitile[0]\r\n        r = minitile[1]\r\n\r\n        x = c * Tile.WIDTH/2 + self._robot.posicion_inicial.x\r\n        y = r * Tile.HEIGHT/2 + self._robot.posicion_inicial.y\r\n        return Point(x, y)\r\n\r\n    def getRectangle(self, minitile_pos):        \r\n        left = minitile_pos.x - Tile.WIDTH/4\r\n        right = minitile_pos.x + Tile.WIDTH/4\r\n        top = minitile_pos.y - Tile.HEIGHT/4\r\n        bottom = minitile_pos.y + Tile.HEIGHT/4\r\n        return Rectangle(top, left, bottom, right)\r\n\r\n    def incrementVisits(self, minitile):\r\n        # (c,r) -> visits \r\n        previous_value = self.minitiles.get(minitile, 0)\r\n        self.minitiles[minitile] = previous_value + 1\r\n\r\n    def getNeighbours(self, coords):\r\n        result = []\r\n        c = coords[0]\r\n        r = coords[1]\r\n        for d in [(-1, 0), (0, -1), ( 1, 0), (0,  1), \\\r\n                  (-1, -1), (1, -1), ( 1,  1), (-1, 1)]:\r\n            result.append((c + d[0], r + d[1]))\r\n        return result\r\n    \r\n    def removeObstructed(self, start, neighbours):\r\n        result = []\r\n        for minitile in neighbours:\r\n            movement = Movement(start, minitile)\r\n            if movement not in self.blockedPaths:\r\n                if not self.isObstructed(minitile):\r\n                    result.append(minitile)\r\n        return result\r\n    \r\n    def findPath(self):\r\n        frontier = deque()\r\n\r\n        start = self.positionToMiniGrid(self._robot.position)\r\n        frontier.append(start)\r\n\r\n        came_from = {} # path A->B is stored as came_from[B] == A\r\n        came_from[start] = None\r\n\r\n        target = None\r\n        while len(frontier) > 0:\r\n            current = frontier.popleft()\r\n\r\n            if current != start and self.minitiles.get(current, 0) == 0:\r\n                target = current\r\n                break\r\n\r\n            neighbours = self.getNeighbours(current)\r\n            neighbours = self.removeObstructed(current, neighbours)\r\n            for next in neighbours:\r\n                if next not in came_from:\r\n                    frontier.append(next)\r\n                    came_from[next] = current\r\n\r\n\r\n        # print(f"Buscando camino desde: {start}")\r\n\r\n        if target is None:\r\n            # print("Exploramos todo el mapa!!")\r\n            # print("Volvamos al inicio...")\r\n            target = (0, 0)\r\n            self.minitiles = {}\r\n\r\n        # En came_from tenemos el camino desde el robot hasta cualquier baldosa\r\n        # (incluida target)\r\n        current = target \r\n        path = []\r\n        while current is not None: \r\n            path.append(current)\r\n            current = came_from.get(current)\r\n        path.reverse() # optional\r\n\r\n        # print(f"Target: {target}")\r\n        # print(path)\r\n        \r\n        return path\r\n\r\n    def whereToGo(self):\r\n        minitile_coord = self.positionToMiniGrid(self._robot.position)\r\n        self.incrementVisits(minitile_coord)\r\n\r\n        self._robot.mapvis.send_minitiles(self._robot)\r\n        # obtener de minitiles, la key del menor value\r\n       \r\n        # print("-------")\r\n        begin_time = time.time()\r\n        path = self.findPath()\r\n        end_time = time.time()\r\n        # print(f"Elapsed time: {(end_time - begin_time) * 1000} ms")\r\n        target = path[1] if len(path) > 1 else path[0]\r\n        # print(f"Actual target: {target}")\r\n\r\n        shouldBrake = True\r\n        if len(path) > 2:\r\n            delta1 = (path[1][0] - path[0][0], path[1][1] - path[0][1])\r\n            # print(f"D1: {delta1}")\r\n            delta2 = (path[2][0] - path[1][0], path[2][1] - path[1][1])\r\n            # print(f"D2: {delta2}")\r\n            if delta1 == delta2:\r\n                # print("PODEMOS NO FRENAR")\r\n                shouldBrake = False\r\n            \r\n        return self.getPosition(target), shouldBrake\r\n    \r\n    def pathHasta(self, colF, filF):\r\n        frontier = deque()\r\n\r\n        start = self.positionToMiniGrid(self._robot.position)\r\n        puntoFinal=self._robot.map.gridToPosition(colF, filF)\r\n        endMinitile=self.positionToMiniGrid(puntoFinal)\r\n\r\n        frontier.append(start)\r\n        # target = self.positionToMiniGrid(self._robot.map.gridToPosition(colF, filF))\r\n\r\n        came_from = {} # path A->B is stored as came_from[B] == A\r\n        came_from[start] = None\r\n\r\n        target = None\r\n        while len(frontier) > 0:\r\n            current = frontier.popleft()\r\n\r\n            # if current != start and self.minitiles.get(current, 0) == 0:\r\n            if current==endMinitile:\r\n                target = current\r\n                break\r\n\r\n            neighbours = self.getNeighbours(current)\r\n            neighbours = self.removeObstructed(current, neighbours)\r\n            for next in neighbours:\r\n                if next not in came_from:\r\n                    frontier.append(next)\r\n                    came_from[next] = current\r\n\r\n\r\n        # print(f"Buscando camino desde: {start}")\r\n\r\n        if target is None:\r\n            # print("Exploramos todo el mapa!!")\r\n            # print("Volvamos al inicio...")\r\n            target = (0, 0)\r\n            self.minitiles = {}\r\n\r\n        # print(f"Came from: {came_from}")\r\n        # En came_from tenemos el camino desde el robot hasta cualquier baldosa\r\n        # (incluida target)\r\n        current = target \r\n        path = []\r\n        while current is not None: \r\n            path.append(current)\r\n            current = came_from.get(current)\r\n        path.reverse() # optional\r\n\r\n        # print(f"Target: {target}")\r\n        # print(path)\r\n        \r\n        return path\r\n\r\n    def whereToGo(self):\r\n        minitile_coord = self.positionToMiniGrid(self._robot.position)\r\n        self.incrementVisits(minitile_coord)\r\n\r\n        self._robot.mapvis.send_minitiles(self._robot)\r\n        # obtener de minitiles, la key del menor value\r\n       \r\n        # print("-------")\r\n        begin_time = time.time()\r\n        path = self.findPath()\r\n        end_time = time.time()\r\n        # print(f"Elapsed time: {(end_time - begin_time) * 1000} ms")\r\n        target = path[1] if len(path) > 1 else path[0]\r\n        # print(f"Actual target: {target}")\r\n\r\n        shouldBrake = True\r\n        if len(path) > 2:\r\n            delta1 = (path[1][0] - path[0][0], path[1][1] - path[0][1])\r\n            # print(f"D1: {delta1}")\r\n            delta2 = (path[2][0] - path[1][0], path[2][1] - path[1][1])\r\n            # print(f"D2: {delta2}")\r\n            if delta1 == delta2:\r\n                # print("PODEMOS NO FRENAR")\r\n                shouldBrake = False\r\n            \r\n        return self.getPosition(target), shouldBrake')
    __stickytape_write_module('comm.py', b'import struct\r\nfrom map import TileType\r\nfrom piso import Piso\r\nfrom math import pi as PI\r\nclass Comm:\r\n    def __init__(self, emitter, receiver, robot):\r\n        self.emitter = emitter\r\n        self.receiver = receiver\r\n        self.robot=robot\r\n\r\n    def sendToken(self, pos1, pos2, letra, rob):\r\n        let = bytes(letra, \'utf-8\')  \r\n        mensaje = struct.pack("i i c i", pos1, pos2, let,rob) \r\n        self.emitter.send(mensaje)\r\n\r\n    def getGameScoreAndtimeRemaining(self):\r\n\r\n        message = struct.pack(\'c\', \'G\'.encode()) # message = \'G\' for game information\r\n        self.emitter.send(message) # send message\r\n        gs=None\r\n        tr=None\r\n        rtr=None\r\n        self.robot.robot.step()\r\n        self.robot.robot.step()\r\n\r\n        if self.receiver.getQueueLength() > 0: # If receiver queue is not empty\r\n            # recorro hasta quedarme s\xc3\xb3lo con el \xc3\xbaltimo\r\n            while self.receiver.getQueueLength() > 1:\r\n                self.receiver.nextPacket()\r\n            receivedData = self.receiver.getBytes()\r\n            lenReceivedData = len(receivedData)\r\n            if lenReceivedData==16: # If received data is of length 16\r\n                # De casualidad descubrimos que tambi\xc3\xa9n devuelve el tiempo del mundo real restante\r\n                tup = struct.unpack(\'c f i i\', receivedData) # Parse data into char, float, int, int\r\n                if tup[0].decode("utf-8") == \'G\':\r\n                    gs=tup[1] #game score\r\n                    tr=tup[2] #time remaining\r\n                    rtr=tup[3] #real time remaining\r\n            self.receiver.nextPacket() # Discard the current data packet\r\n            \r\n        return gs, tr, rtr\r\n\r\n    def sendMap(self, rep):\r\n     ## Get shape\r\n        s = rep.shape\r\n        ## Get shape as bytes\r\n        s_bytes = struct.pack(\'2i\',*s)\r\n\r\n        ## Flattening the matrix and join with \',\'\r\n        flatMap = \',\'.join(rep.flatten())\r\n        ## Encode\r\n        sub_bytes = flatMap.encode(\'utf-8\')\r\n\r\n        ## Add togeather, shape + map\r\n        a_bytes = s_bytes + sub_bytes\r\n\r\n        ## Send map data\r\n        self.emitter.send(a_bytes)\r\n\r\n        #STEP3 Send map evaluate request\r\n        map_evaluate_request = struct.pack(\'c\', b\'M\')\r\n        self.emitter.send(map_evaluate_request)\r\n    \r\n    def sendExit(self):\r\n        ## Exit message\r\n        exit_mes = struct.pack(\'c\', b\'E\')\r\n        self.emitter.send(exit_mes)\r\n\r\n    def llegueAVioleta(self, fila, columna):\r\n        print(f"Yo {self.robot.yo} Mando mensaje V con {fila}, {columna}")\r\n        message = struct.pack(\'c i i i i\', \'V\'.encode(), fila, columna, self.robot.otro, 42) \r\n        self.emitter.send(message)\r\n\r\n    def quedateAhi(self, fila, columna):\r\n        print(f"Yo {self.robot.yo} Mando mensaje Q con {fila}, {columna}")\r\n        message = struct.pack(\'c i i i i\', \'Q\'.encode(), fila, columna, self.robot.otro, 42) \r\n        self.emitter.send(message)\r\n\r\n    def yaTerminamos(self, fila, columna):\r\n        print(f"Yo {self.robot.yo} Mando mensaje Y con {fila}, {columna}")\r\n        message = struct.pack(\'c i i i i\', \'Y\'.encode(), fila, columna, self.robot.otro, 42) \r\n        self.emitter.send(message)\r\n\r\n    def andaPalla(self, fila, columna, rob):\r\n        print(f"Yo {self.robot.yo} Mando mensaje A con {fila}, {columna}")\r\n        message = struct.pack(\'c i i i i\', \'A\'.encode(), fila, columna, rob, 42) \r\n        self.emitter.send(message)\r\n\r\n    def recibirMensajes(self):\r\n        if self.receiver.getQueueLength() > 0: # If receiver queue is not empty\r\n            receivedData = self.receiver.getBytes()\r\n \r\n            while self.receiver.getQueueLength()> 0 and len(receivedData)!=20:\r\n                # print(len(receivedData))\r\n                self.receiver.nextPacket()\r\n                receivedData = self.receiver.getBytes()\r\n            print("LArgo: ",len(receivedData))\r\n            if self.receiver.getQueueLength()>0:\r\n                paq=struct.unpack("c i i i i", receivedData)\r\n                self.receiver.nextPacket()\r\n                mensaje=paq[0].decode("utf-8")\r\n                col=paq[1]\r\n                fila=paq[2]\r\n                destino=paq[3]\r\n                print(f"Yo {self.robot.yo} Recibi {mensaje} con {col} y {fila} y {destino}")\r\n                if destino==self.robot.yo:\r\n                    if mensaje=="V":\r\n                        self.robot.violetasDelOtro.append((col, fila))\r\n                        print(f"Yo soy {self.robot.yo} Las violetas del otro tienen ", self.robot.violetasDelOtro)\r\n                        # Ver qu\xc3\xa9 hacer si los dos ya vieron los dos\r\n                        if len(self.robot.violetasDelOtro)==2 and len(self.robot.misVioletas)==2:\r\n                            \r\n                            # sort a list of tuples by 1st item and then 2nd item\r\n                            self.robot.violetasDelOtro.sort(key = lambda x: (x[0], x[1]))\r\n                            self.robot.misVioletas.sort(key = lambda x: (x[0], x[1]))\r\n                            difCol=self.robot.violetasDelOtro[0][0]-self.robot.misVioletas[0][0]\r\n                            difFila=self.robot.violetasDelOtro[0][1]-self.robot.misVioletas[0][1]\r\n                            print(f" Yo {self.robot.yo} Violetas del otro",self.robot.violetasDelOtro)\r\n                            print(f" Yo {self.robot.yo} Mis Violetas", self.robot.misVioletas)\r\n                            print("Donde me dijo que estaba el otro en su sistema de referencia", col, fila)\r\n                            colOtro=col-difCol\r\n                            filaOtro=fila-difFila\r\n                            # Obtengo el camino que tengo entre mi posici\xc3\xb3n y la primera violeta\r\n                            caminoAPrimera=self.robot.navigator.pathHasta(self.robot.misVioletas[0][0], self.robot.misVioletas[0][1])\r\n                            # if (colOtro, filaOtro) is in the keys of caminoAPrimera\r\n                            print(caminoAPrimera)\r\n                            posicion=self.robot.map.gridToPosition(colOtro, filaOtro)\r\n                            posMT=self.robot.navigator.positionToMiniGrid(posicion)\r\n                            print(f"posMT {posMT}")\r\n                            if (posMT[0], posMT[1]) in caminoAPrimera:\r\n                                print(f"{self.robot.otro} est\xc3\xa1 en mi camino para llegar al violeta 1. Lo mando a \xc3\xa9l")\r\n                                self.andaPalla(self.robot.violetasDelOtro[0][0], self.robot.violetasDelOtro[0][1], self.robot.otro)\r\n                                self.robot.delay(1000)\r\n                                self.robot.moveToPoint(self.robot.map.gridToPosition(self.robot.misVioletas[1][0], self.robot.misVioletas[1][1]), True)\r\n                                self.robot.parar()\r\n                                self.robot.delay(6000)\r\n                                self.anulaVecinas()\r\n                                self.yaTerminamos(colOtro, filaOtro)\r\n                                self.robot.ZonaTerminada=False\r\n                                self.robot.violetasDelOtro=[]\r\n                                self.robot.misVioletas=[]\r\n\r\n                            else:\r\n                                self.quedateAhi(col, fila)\r\n                                self.robot.moveToPoint(self.robot.map.gridToPosition(self.robot.misVioletas[1][0], self.robot.misVioletas[1][1]), True)\r\n                                self.robot.parar()\r\n                                self.robot.delay(6000)\r\n                                self.anulaVecinas()\r\n                                self.yaTerminamos(colOtro, filaOtro)\r\n                                self.robot.ZonaTerminada=False\r\n                                self.robot.violetasDelOtro=[]\r\n                                self.robot.misVioletas=[]\r\n\r\n\r\n                    elif mensaje=="Q":\r\n                        self.robot.parar()\r\n                        while self.robot.step() != -1:\r\n                            if self.robot.zonaTerminada:\r\n                                print("Pasamos a la otra zona")\r\n                                self.robot.ZonaTerminada=False\r\n                                self.robot.violetasDelOtro=[]\r\n                                self.robot.misVioletas=[]\r\n                                break\r\n                    elif mensaje=="Y":\r\n                        self.robot.ZonaTerminada=True\r\n                    elif mensaje=="A":\r\n                        self.robot.moveToPoint(self.robot.map.gridToPosition(col, fila), True)\r\n                        self.robot.parar()\r\n                        self.robot.delay(6000)\r\n                        self.anulaVecinas()\r\n                        self.robot.ZonaTerminada=False\r\n                        self.robot.violetasDelOtro=[]\r\n                        self.robot.misVioletas=[]\r\n\r\n    def anulaVecinas(self):\r\n        posicion=self.robot.map.positionToGrid(self.robot.position)\r\n        col=posicion[0]\r\n        fila=posicion[1]\r\n        tile=self.robot.map.getTileAt(col, fila)\r\n        tileN=self.robot.map.getTileAt(col, fila-1)\r\n        tileS=self.robot.map.getTileAt(col, fila+1)\r\n        tileE=self.robot.map.getTileAt(col+1, fila)\r\n        tileO=self.robot.map.getTileAt(col-1, fila)\r\n        shift = self.robot.lidar.rotToLidar(self.robot.rotation)\r\n        lid = self.robot.lidar.rangeImage[shift:] + self.robot.lidar.rangeImage[:shift]\r\n        if lid[0]>0.1:\r\n            tileS.type=TileType.BLACK_HOLE\r\n            tile.south=[1,1,1]\r\n        else:\r\n            tile.south=[0,0,0]\r\n        if lid[128]>0.1:\r\n            tileO.type=TileType.BLACK_HOLE\r\n            tile.oeste=[1,1,1]\r\n        else:\r\n            tile.oeste=[0,0,0]\r\n        if lid[256]>0.1:\r\n            tileN.type=TileType.BLACK_HOLE\r\n            tile.norte=[1,1,1]\r\n        else:\r\n            tile.norte=[0,0,0]\r\n        if lid[384]>0.1:\r\n            tileE.type=TileType.BLACK_HOLE\r\n            tile.este=[1,1,1]\r\n        else:\r\n            tile.este=[0,0,0]\r\n        \r\n        for i in range(0, 4):\r\n            b, g, r, _ = self.robot.colorSensor.getImage()\r\n            m = Piso(r, g, b)\r\n            if m.checkpoint():\r\n                self.robot.avanzar(0.12, True)\r\n                break\r\n            else:\r\n                self.robot.girar(PI/2)\r\n\r\n\r\n\r\n        \r\n                ')
    __stickytape_write_module('visualization.py', b'import socket\r\nimport json\r\nimport threading\r\nimport traceback\r\nimport json\r\nfrom enum import Enum\r\n\r\n\r\ndef to_json_dict(obj):\r\n    if obj is None: return obj\r\n    if isinstance(obj, str): return obj\r\n    if isinstance(obj, int): return obj\r\n    if isinstance(obj, bool): return obj\r\n    if isinstance(obj, float): return obj\r\n    if isinstance(obj, Enum): return obj.value\r\n    if isinstance(obj, tuple):\r\n        return to_json_dict(list(obj))\r\n    if isinstance(obj, set):\r\n        return to_json_dict(list(obj))\r\n\r\n    if isinstance(obj, list):\r\n        result = []\r\n        for e in obj:\r\n            result.append(to_json_dict(e))\r\n        return result\r\n    \r\n    if isinstance(obj, dict):\r\n        result = {}\r\n        for key in obj:\r\n            if isinstance(key, str) or isinstance(key, int) or isinstance(key, bool):\r\n                result[key] = to_json_dict(obj[key])\r\n            else:\r\n                result[str(key)] = to_json_dict(obj[key])\r\n        return result\r\n    \r\n    d = {}\r\n    for k, v in obj.__dict__.items():\r\n        if not k.startswith("_"):\r\n            d[k] = v\r\n    return to_json_dict(d)\r\n\r\nclass JSON:\r\n    @classmethod\r\n    def stringify(self, obj):\r\n        return json.dumps(to_json_dict(obj))\r\n    \r\nclass MapVisualizer:\r\n    def __init__(self, port=4321) -> None:\r\n        self.port = port\r\n        self.host = "127.0.0.1"\r\n        self.connection = None\r\n        self.start()\r\n\r\n        self.previousMessage = {}\r\n        self.lastRobotUpdate = 0\r\n\r\n    def start(self):\r\n        self.thread = threading.Thread(target=self.accept_connections, args=(), daemon=True)\r\n        self.thread.start()\r\n\r\n    def accept_connections(self):\r\n        return None\r\n        print("Waiting for connections...")\r\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n            s.bind((self.host, self.port))\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            print(f"Connected by {addr}")\r\n            self.connection = conn\r\n\r\n    def send_map(self, map):\r\n        if self.connection == None: return\r\n        try:\r\n            type = 0\r\n            data = JSON.stringify(map).encode("utf8")\r\n            if data == self.previousMessage.get(type): return\r\n            self.previousMessage[type] = data\r\n            type = type.to_bytes(1, byteorder="little")\r\n            count = len(data).to_bytes(4, "little")\r\n            self.connection.sendall(type + count + data)\r\n        except Exception:\r\n            print("Connection lost!")\r\n            print(traceback.format_exc())\r\n            self.connection.close()\r\n            self.connection = None\r\n            self.start()\r\n\r\n    def send_robot(self, robot):        \r\n        if self.connection == None: return\r\n        try:\r\n            if robot.step_counter - self.lastRobotUpdate < 4:\r\n                return\r\n            self.lastRobotUpdate = robot.step_counter\r\n            type = 1\r\n            data = {\r\n                "position": robot.position,\r\n                "rotation": robot.rotation,\r\n                "current_area": robot.current_area,\r\n                "targetPoint": robot.targetPoint,\r\n                "initial_position": robot.posicion_inicial\r\n            }\r\n            data = JSON.stringify(data).encode("utf8")\r\n            if data == self.previousMessage.get(type): return\r\n            self.previousMessage[type] = data\r\n            type = type.to_bytes(1,byteorder="little")\r\n            count = len(data).to_bytes(4, "little")\r\n            self.connection.sendall(type + count + data)\r\n        except Exception:\r\n            print("Connection lost!")\r\n            print(traceback.format_exc())\r\n            self.connection.close()\r\n            self.connection = None\r\n            self.start()\r\n\r\n    \r\n    def send_minitiles(self, robot):\r\n        if self.connection == None: return\r\n        try:\r\n            type = 2\r\n            data = robot.navigator.minitiles\r\n            data = JSON.stringify(data).encode("utf8")\r\n            if data == self.previousMessage.get(type): return\r\n            self.previousMessage[type] = data\r\n            type = type.to_bytes(1, byteorder="little")\r\n            count = len(data).to_bytes(4, "little")\r\n            self.connection.sendall(type + count + data)\r\n        except Exception:\r\n            print("Connection lost!")\r\n            print(traceback.format_exc())\r\n            self.connection.close()\r\n            self.connection = None\r\n            self.start()')
    __stickytape_write_module('persona.py', b'YO=0\r\n\r\nOTRO=1\r\n')
    from robot import Robot
    from point import Point
    import cv2
    from math import pi as PI
    from map import TileType
    from piso import Piso
    
    robot = Robot()
    
    # robot.moveToPoint(Point(robot.position.x-0.28, robot.position.y))
    # robot.moveToPoint(Point(robot.position.x, robot.position.y+0.02))
    # b,g,r,_=robot.colorSensor.getImage()
    # print(r,g,b)
    # robot.parar()
    # robot.delay(10000)
    
    # robot.moveToPoint(Point(robot.position.x+0.36, robot.position.y))
    # robot.moveToPoint(Point(robot.position.x, robot.position.y+0.24))
    
    
    while robot.step() != -1:
        navigator = robot.getNavigator()
        point, shouldBrake = navigator.whereToGo()
    
        sendMapNow = False #robot.position.distance_to(point) < 0.025
        
        if not sendMapNow:
            robot.moveToPoint(point, shouldBrake)
        
        if sendMapNow or robot.timeRemaining < 10 or robot.realTimeRemaining < 10:
            rep=robot.map.getRepresentation()
            robot.comm.sendMap(rep)
            # print(rep)
            robot.comm.sendExit()
        
        # # for tiles in robot.map.getValidTiles():
        #     print(tiles)
        # print("############################################################")
        # valid_tiles = robot.map.getValidTiles()
        # for tile in valid_tiles:
        #     print(tile.col, tile.row)
        #     print(tile.tokensWest)
        #     print(tile.tokensVerticalInternalWall)
        #     print(tile.tokensEast)
        #     print("------")
    